<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Bizkaibus en Tiempo Real</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 1em;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5em;
      margin-bottom: 1em;
    }
    input {
      padding: 0.5em; font-size: 1em;
      width: 300px; max-width: 90vw; box-sizing: border-box;
    }
    button {
      padding: 0.5em 1em; font-size: 1em; cursor: pointer;
    }
    #map {
      height: 80vh;
      width: 100%; max-width: 1750px;
    }
    #stop-results {
      margin-top: 1em;
      width: 100%;
      max-width: 1750px;
      text-align: left;
    }
    #stop-results h2 {
        text-align: center;
        margin-bottom: 0.5em;
    }
    #bus-list {
      list-style: none;
      padding: 0;
      margin-top: 1em;
    }
    .bus-option {
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      margin-bottom: 0.5em;
      padding: 0.8em;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      flex-wrap: wrap; /* Permite que los elementos se envuelvan en pantallas peque침as */
    }
    .bus-option:hover {
      background-color: #e0e0e0;
    }
    .bus-option-linea {
      font-weight: bold;
      color: #333;
      flex-basis: 30%; /* Ajuste para mejor distribuci칩n */
      text-align: left;
    }
    .bus-option-hora {
      font-weight: bold;
      color: #0056b3;
      flex-basis: 20%; /* Ajuste para mejor distribuci칩n */
      text-align: center;
    }
    .bus-option-destino {
      font-weight: bold;
      color: #666;
      font-size: 0.9em;
      flex-basis: 45%; /* Ajuste para mejor distribuci칩n */
      text-align: right;
    }
    @media (max-width: 600px) {
        .bus-option-linea, .bus-option-hora, .bus-option-destino {
            flex-basis: 100%;
            text-align: center;
        }
        .bus-option-linea { order: 1; }
        .bus-option-hora { order: 2; margin-top: 0.2em; }
        .bus-option-destino { order: 3; font-size: 0.8em;}
    }

    /* Estilos para el estado del retraso */
    .delay-text-stop-list {
        font-weight: normal;
        margin-left: 5px;
        font-size: 0.9em;
    }
    .delay-text-stop-list.delay {
        color: #d9534f; /* Rojo para retraso */
    }
    .delay-text-stop-list.advance {
        color: #5cb85c; /* Verde para adelanto */
    }
    .delay-text-stop-list.on-time {
        color: #5bc0de; /* Azul claro para en hora (o m칤nimo cambio) */
    }

    #route-details {
        margin-top: 1em;
        width: 100%;
        max-width: 1750px;
        text-align: left;
    }
    #route-details h2 {
        text-align: center;
        margin-bottom: 0.5em;
    }
    #delay-info {
        text-align: center;
        font-weight: bold;
        margin-bottom: 0.8em;
        font-size: 1.1em;
    }
    .delay-text.delay {
        color: #d9534f; /* Rojo para retraso */
    }
    .delay-text.advance {
        color: #5cb85c; /* Verde para adelanto */
    }
    .delay-text.on-time {
        color: #5bc0de; /* Azul claro para en hora */
    }

    #route-stop-list {
        list-style: none;
        padding: 0;
    }
    #route-stop-list li {
        margin-bottom: 0.3em;
        font-size: 0.95em;
        border-bottom: 1px dotted #eee;
        padding-bottom: 0.3em;
    }
    #route-stop-list li:last-child {
        border-bottom: none;
    }
    .scheduled-time {
        font-weight: bold;
        margin-right: 0.5em;
    }
    .estimated-time {
        color: #888;
        font-size: 0.85em;
    }
    .waypoint-icon {
        margin-left: 5px;
        font-size: 1.2em;
    }
  </style>
</head>
<body>
  <h1>Localizador de Bizkaibus</h1>
  <div id="controls">
    <input type="text" id="parada" placeholder="Buscar parada (ej: 48000001)" />
    <button onclick="buscarBusesPorParada()">Buscar por Parada</button>
    <input type="text" id="linea" placeholder="Buscar l칤nea (ej: A3224)" />
    <button onclick="buscarLineas()">Buscar por L칤nea</button>
    <button onclick="clearMapElements()">Limpiar Mapa</button>
  </div>

  <div id="map"></div>

  <div id="stop-results" style="display: none;">
    <h2></h2>
    <div id="bus-list"></div>
  </div>

  <div id="route-details" style="display: none;">
    <h2>Detalles del Recorrido</h2>
    <div id="delay-info"></div>
    <ul id="route-stop-list"></ul>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    let map;
    let markers = [];
    let lineMarkers = []; // Marcadores para la b칰squeda por l칤nea
    let stopMarkers = []; // Marcadores para la b칰squeda por parada
    let routePolyline;
    let realTimeBusMarker; // Marcador del bus en tiempo real

    let busLinesData = new Map();
    let stopsData = new Map();
    let stopTimesData = [];
    let tripsData = new Map();
    let calendarData = new Map();
    let calendarDatesData = new Map();

    let currentBusDelayInSeconds = null;
    let currentBusStopIdRealTime = null;

    // Inicializar el mapa
    map = L.map('map').setView([43.256944, -2.923611], 12); // Coordenadas de Bilbao

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    function clearMapElements() {
      markers.forEach(marker => map.removeLayer(marker));
      markers = [];
      lineMarkers.forEach(marker => map.removeLayer(marker));
      lineMarkers = [];
      stopMarkers.forEach(marker => map.removeLayer(marker));
      stopMarkers = [];
      if (routePolyline) {
        map.removeLayer(routePolyline);
        routePolyline = null;
      }
      if (realTimeBusMarker) {
        map.removeLayer(realTimeBusMarker);
        realTimeBusMarker = null;
      }
      document.getElementById('delay-info').textContent = '';
      document.getElementById('route-details').style.display = 'none';
    }

    function clearLineSearchMarkers() {
        lineMarkers.forEach(marker => map.removeLayer(marker));
        lineMarkers = [];
    }

    // Cargar datos GTFS
    async function cargarDatosGTFS() {
        try {
            const [routesResp, stopsResp, stopTimesResp, tripsResp, calendarResp, calendarDatesResp] = await Promise.all([
                fetch("data/routes.txt"),
                fetch("data/stops.txt"),
                fetch("data/stop_times.txt"),
                fetch("data/trips.txt"),
                fetch("data/calendar.txt"),
                fetch("data/calendar_dates.txt")
            ]);

            const [routesText, stopsText, stopTimesText, tripsText, calendarText, calendarDatesText] = await Promise.all([
                routesResp.text(),
                stopsResp.text(),
                stopTimesResp.text(),
                tripsResp.text(),
                calendarResp.text(),
                calendarDatesResp.text()
            ]);

            // routes.txt
            routesText.split('\n').slice(1).forEach(line => {
                const parts = line.split(',');
                if (parts.length > 1) {
                    busLinesData.set(parts[0].trim(), { // route_id
                        route_id: parts[0].trim(),
                        agency_id: parts[1].trim(),
                        route_short_name: parts[2].trim(),
                        route_long_name: parts[3].trim(),
                        route_desc: parts[4] ? parts[4].trim() : '',
                        route_type: parts[5] ? parts[5].trim() : '',
                        route_color: parts[6] ? parts[6].trim() : '',
                        route_text_color: parts[7] ? parts[7].trim() : ''
                    });
                }
            });

            // stops.txt
            stopsText.split('\n').slice(1).forEach(line => {
                const parts = line.split(',');
                if (parts.length > 3) {
                    stopsData.set(parts[0].trim(), { // stop_id
                        stop_id: parts[0].trim(),
                        stop_code: parts[1] ? parts[1].trim() : '',
                        stop_name: parts[2].trim(),
                        stop_lat: parseFloat(parts[3]),
                        stop_lon: parseFloat(parts[4]),
                        zone_id: parts[5] ? parts[5].trim() : ''
                    });
                }
            });

            // stop_times.txt
            stopTimesText.split('\n').slice(1).forEach(line => {
                const parts = line.split(',');
                if (parts.length > 4) {
                    stopTimesData.push({
                        trip_id: parts[0].trim(),
                        arrival_time: parts[1].trim(),
                        departure_time: parts[2].trim(),
                        stop_id: parts[3].trim(),
                        stop_sequence: parseInt(parts[4]),
                        stop_headsign: parts[5] ? parts[5].trim() : '',
                        pickup_type: parts[6] ? parts[6].trim() : '',
                        drop_off_type: parts[7] ? parts[7].trim() : '',
                        shape_dist_traveled: parts[8] ? parseFloat(parts[8]) : 0
                    });
                }
            });

            // trips.txt
            tripsText.split('\n').slice(1).forEach(line => {
                const parts = line.split(',');
                if (parts.length > 5) {
                    tripsData.set(parts[2].trim(), { // trip_id
                        route_id: parts[0].trim(),
                        service_id: parts[1].trim(),
                        trip_id: parts[2].trim(),
                        trip_headsign: parts[3].trim(),
                        direction_id: parseInt(parts[4]),
                        block_id: parts[5] ? parts[5].trim() : '',
                        shape_id: parts[6] ? parts[6].trim() : ''
                    });
                }
            });

            // calendar.txt
            calendarText.split('\n').slice(1).forEach(line => {
                const parts = line.split(',');
                if (parts.length > 9) {
                    calendarData.set(parts[0].trim(), { // service_id
                        service_id: parts[0].trim(),
                        monday: parseInt(parts[1]),
                        tuesday: parseInt(parts[2]),
                        wednesday: parseInt(parts[3]),
                        thursday: parseInt(parts[4]),
                        friday: parseInt(parts[5]),
                        saturday: parseInt(parts[6]),
                        sunday: parseInt(parts[7]),
                        start_date: parts[8].trim(),
                        end_date: parts[9].trim()
                    });
                }
            });

            // calendar_dates.txt
            calendarDatesText.split('\n').slice(1).forEach(line => {
                const parts = line.split(',');
                if (parts.length > 2) {
                    const serviceId = parts[0].trim();
                    const date = parts[1].trim();
                    const exceptionType = parseInt(parts[2]);
                    if (!calendarDatesData.has(serviceId)) {
                        calendarDatesData.set(serviceId, new Map());
                    }
                    calendarDatesData.get(serviceId).set(date, exceptionType);
                }
            });

            console.log("Datos GTFS cargados correctamente.");
        } catch (error) {
            console.error("Error cargando datos GTFS:", error);
            alert("Error al cargar los datos de las l칤neas de autob칰s.");
        }
    }

    function timeToSeconds(timeStr) {
        const parts = timeStr.split(':');
        return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);
    }

    function secondsToTime(totalSeconds) {
        totalSeconds = Math.max(0, totalSeconds); // Asegura que no sea negativo
        const hours = Math.floor(totalSeconds / 3600);
        totalSeconds %= 3600;
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function getCleanStopName(stopId) {
        const stopInfo = stopsData.get(stopId);
        if (stopInfo && stopInfo.stop_name) {
            // Eliminar sufijos como "(Kurutze)", "(Gurutzeta)", etc.
            return stopInfo.stop_name.replace(/\s*\([\w\s-]*\)$/, '').trim();
        }
        return `Parada ${stopId}`;
    }


    async function buscarBusesPorParada() {
        const stopIdInput = document.getElementById("parada").value.trim();
        if (!stopIdInput) {
            return alert("Introduce un n칰mero de parada v치lido.");
        }
        const stopId = stopIdInput;
        
        if (!stopsData.has(stopId)) {
            return alert("Parada no encontrada. Introduce un ID de parada v치lido.");
        }

        clearLineSearchMarkers();
        clearMapElements();  

        document.getElementById('route-details').style.display = 'none';

        const busListDiv = document.getElementById("bus-list");
        busListDiv.innerHTML = "Cargando pr칩ximos autobuses...";
        document.getElementById('stop-results').style.display = 'block';
        const stopNameForTitle = getCleanStopName(stopId);
        document.getElementById('stop-results').querySelector('h2').textContent = `Pr칩ximos autobuses en parada: ${stopNameForTitle} (${stopId})`;

        const now = new Date();
        const currentDayOfWeek = now.getDay(); 
        const currentYear = now.getFullYear();
        const currentMonth = (now.getMonth() + 1).toString().padStart(2, '0');
        const currentDay = now.getDate().toString().padStart(2, '0');
        const currentDate = `${currentYear}${currentMonth}${currentDay}`;
        // Convertir currentTime a segundos para facilitar comparaciones
        const currentSeconds = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();

        // INICIO DEL BLOQUE MOVIDO Y ACTUALIZADO
        // Obtener actividades en tiempo real una vez al principio de la funci칩n
        const realTimeActivities = new Map();
        try {
            const rtResp = await fetch("https://bizkaibus.onrender.com/bizkaibus");
            const rtXmlText = await rtResp.text();
            const rtXml = new DOMParser().parseFromString(rtXmlText, "application/xml");
            const rtActivityElements = rtXml.getElementsByTagName("VehicleActivity");

            for (let act of rtActivityElements) {
                const jref = act.querySelector("VehicleJourneyRef")?.textContent.trim();
                if (jref) {
                    realTimeActivities.set(jref, { 
                        vehicleRef: act.querySelector("VehicleRef")?.textContent.trim(),
                        stopPointRef: act.querySelector("StopPointRef")?.textContent.trim(), 
                        recordedAtTimeISO: act.querySelector("RecordedAtTime")?.textContent.trim() 
                    });
                }
            }
        } catch (e) {
            console.warn("No se pudieron obtener datos en tiempo real para estimaciones en lista de paradas:", e);
        }
        // FIN DEL BLOQUE MOVIDO Y ACTUALIZADO

        const upcomingBuses = [];
        const stopTimesAtThisStop = stopTimesData.filter(st => st.stop_id === stopId);

        // Obtener la stop_sequence de la parada actual para compararla
        const currentStopSequence = stopTimesData.find(st => st.stop_id === stopId)?.stop_sequence;

        for (const st of stopTimesAtThisStop) {
            const trip = tripsData.get(st.trip_id);
            if (!trip) continue;

            const service = calendarData.get(trip.service_id);
            if (!service) continue;

            const serviceStartDate = parseInt(service.start_date);
            const serviceEndDate = parseInt(service.end_date);
            const currentFormattedDate = parseInt(currentDate);

            if (currentFormattedDate < serviceStartDate || currentFormattedDate > serviceEndDate) {
                continue; 
            }

            const serviceExceptions = calendarDatesData.get(trip.service_id);
            const currentException = serviceExceptions ? serviceExceptions.get(currentDate) : undefined;

            let runsToday = false;

            if (currentException === 1) { 
                runsToday = true;
            } else if (currentException === 2) { 
                runsToday = false;
            } else { 
                switch (currentDayOfWeek) {
                    case 0: runsToday = service.sunday === 1; break; 
                    case 1: runsToday = service.monday === 1; break;
                    case 2: runsToday = service.tuesday === 1; break;
                    case 3: runsToday = service.wednesday === 1; break;
                    case 4: runsToday = service.thursday === 1; break;
                    case 5: runsToday = service.friday === 1; break;
                    case 6: runsToday = service.saturday === 1; break;
                }
            }
            
            if (!runsToday) continue;

            // L칩gica de filtrado en tiempo real MEJORADA
            let hasBusPassed = false;
            let estimatedDepartureSeconds = timeToSeconds(st.departure_time); // Hora PROGRAMADA, base para la estimada

            const liveBusData = realTimeActivities.get(st.trip_id);
            if (liveBusData && liveBusData.stopPointRef) {
                const realTimeBusStopSequence = stopTimesData.find(
                    rt_st => rt_st.trip_id === st.trip_id && rt_st.stop_id === liveBusData.stopPointRef
                )?.stop_sequence;

                if (realTimeBusStopSequence !== undefined && currentStopSequence !== undefined) {
                    if (realTimeBusStopSequence >= currentStopSequence) {
                        hasBusPassed = true; // El bus ya ha pasado o est치 en la parada o m치s all치
                    } else { // El bus a칰n no ha llegado a la parada de b칰squeda (realTimeBusStopSequence < currentStopSequence)
                        // Calcular el retraso/adelanto en la posici칩n actual del bus y aplicarlo
                        const liveBusStopSchedule = stopTimesData.find(
                            rt_st => rt_st.trip_id === st.trip_id && rt_st.stop_id === liveBusData.stopPointRef
                        );

                        if (liveBusStopSchedule && liveBusData.recordedAtTimeISO) {
                            const scheduledTimeAtLiveBusStopSeconds = timeToSeconds(liveBusStopSchedule.arrival_time);
                            const realTimeDate = new Date(liveBusData.recordedAtTimeISO);
                            const actualTimeAtLiveBusStopSeconds = realTimeDate.getHours() * 3600 + realTimeDate.getMinutes() * 60 + realTimeDate.getSeconds();
                            
                            const delayAtLiveBusStopSeconds = actualTimeAtLiveBusStopSeconds - scheduledTimeAtLiveBusStopSeconds;
                            
                            // Aplicar este retraso/adelanto a la hora de salida PROGRAMADA de *nuestra* parada de b칰squeda
                            estimatedDepartureSeconds = timeToSeconds(st.departure_time) + delayAtLiveBusStopSeconds;
                        }
                    }
                }
            }

            // FILTRADO FINAL:
            // Solo a침adir el bus si su HORA ESTIMADA DE SALIDA es en el futuro
            // Y si NO ha pasado la parada seg칰n su posici칩n en tiempo real.
            if (estimatedDepartureSeconds > currentSeconds && !hasBusPassed) {
                upcomingBuses.push({
                    linea: trip.route_id,
                    hora: st.departure_time, // Se sigue mostrando la hora programada en la lista
                    destino: trip.trip_headsign,
                    trip_id: st.trip_id,
                    shape_id: trip.shape_id,
                    estimated_hora_seconds: estimatedDepartureSeconds // Guardamos la estimada para ordenar
                });
            }
        }

        // Ordenar los autobuses por su hora estimada de llegada
        upcomingBuses.sort((a, b) => a.estimated_hora_seconds - b.estimated_hora_seconds);
        busListDiv.innerHTML = ""; 

        if (upcomingBuses.length > 0) {
            const stopInfo = stopsData.get(stopId);
            if (stopInfo) { 
                const paradaTexto = getCleanStopName(stopId);
                const stopMarker = L.marker([stopInfo.stop_lat, stopInfo.stop_lon]).addTo(map);
                stopMarker.bindPopup(`<b>Parada:</b> ${paradaTexto} (${stopId})`).openPopup();
                stopMarkers.push(stopMarker); 
                map.setView([stopInfo.stop_lat, stopInfo.stop_lon], 15);
            }

            upcomingBuses.slice(0, 10).forEach(bus => { 
                const busOption = document.createElement("div");
                busOption.classList.add("bus-option");

                // CAMBIO: Mostrar solo HH:MM
                let scheduledTimeDisplay = bus.hora.substring(0, 5);
                let delayStatusText = "";

                // Calcular el delay para mostrar la etiqueta (+Xm)/(-Xm)
                if (realTimeActivities.has(bus.trip_id)) {
                    const liveBusData = realTimeActivities.get(bus.trip_id); 
                    
                    const liveBusStopSchedule = stopTimesData.find(
                        st_rt => st_rt.trip_id === bus.trip_id && st_rt.stop_id === liveBusData.stopPointRef
                    );

                    if (liveBusStopSchedule && liveBusData.recordedAtTimeISO) {
                        const scheduledTimeAtLiveBusStopSeconds = timeToSeconds(liveBusStopSchedule.arrival_time);
                        
                        const realTimeDate = new Date(liveBusData.recordedAtTimeISO);
                        const actualTimeAtLiveBusStopSeconds = realTimeDate.getHours() * 3600 + realTimeDate.getMinutes() * 60 + realTimeDate.getSeconds();

                        if (scheduledTimeAtLiveBusStopSeconds > 0 && actualTimeAtLiveBusStopSeconds > 0) {
                            const delayAtLiveBusStopSeconds = actualTimeAtLiveBusStopSeconds - scheduledTimeAtLiveBusStopSeconds;
                            const delayMinutes = Math.round(delayAtLiveBusStopSeconds / 60);

                            if (delayMinutes > 1) { 
                                delayStatusText = `<span class="delay-text-stop-list delay">(+${delayMinutes}m)</span>`;
                            } else if (delayMinutes < -1) { 
                                // CAMBIO: Mostrar el signo negativo en adelantos
                                delayStatusText = `<span class="delay-text-stop-list advance">(${delayMinutes}m)</span>`;
                            } else if (delayMinutes !== 0) { 
                                delayStatusText = `<span class="delay-text-stop-list on-time">(${delayMinutes > 0 ? '+' : ''}${delayMinutes}m)</span>`;
                            } else if (delayMinutes == 0) { 
                                delayStatusText = `<span class="delay-text-stop-list advance">(En hora)</span>`;
                            }
                        }
                    }
                }
                busOption.innerHTML = `
                    <span class="bus-option-linea">L칤nea: ${bus.linea}</span>
                    <span class="bus-option-hora">${scheduledTimeDisplay}${delayStatusText}</span>
                    <span class="bus-option-destino">Destino: ${bus.destino}</span>
                `;
                busOption.onclick = () => {
                    mostrarRecorrido(bus.trip_id, bus.shape_id); 
                };
                busListDiv.appendChild(busOption);
            });
        } else {
            busListDiv.innerHTML = `<p>No hay pr칩ximos autobuses programados para esta parada hoy (${now.toTimeString().substring(0,5)}).</p>`;
        }
    }

    async function buscarLineas() {
        const lineIdInput = document.getElementById("linea").value.trim().toUpperCase();
        if (!lineIdInput) {
            return alert("Introduce una l칤nea v치lida (ej: A3224).");
        }

        clearMapElements();
        document.getElementById('stop-results').style.display = 'none';

        const lineInfo = busLinesData.get(lineIdInput);
        if (!lineInfo) {
            return alert(`L칤nea ${lineIdInput} no encontrada.`);
        }

        const tripsForLine = Array.from(tripsData.values()).filter(trip => trip.route_id === lineIdInput);
        if (tripsForLine.length === 0) {
            return alert(`No se encontraron viajes para la l칤nea ${lineIdInput}.`);
        }

        const stopsForLine = new Map();
        let bounds = new L.LatLngBounds();

        // Recopilar todas las paradas 칰nicas para esta l칤nea
        tripsForLine.forEach(trip => {
            stopTimesData.filter(st => st.trip_id === trip.trip_id).forEach(st => {
                const stopInfo = stopsData.get(st.stop_id);
                if (stopInfo && !stopsForLine.has(stopInfo.stop_id)) {
                    stopsForLine.set(stopInfo.stop_id, stopInfo);
                    const marker = L.marker([stopInfo.stop_lat, stopInfo.stop_lon]).addTo(map);
                    marker.bindPopup(`<b>Parada:</b> ${getCleanStopName(stopInfo.stop_id)} (${stopInfo.stop_id})`);
                    lineMarkers.push(marker);
                    bounds.extend([stopInfo.stop_lat, stopInfo.stop_lon]);
                }
            });
        });

        if (stopsForLine.size > 0) {
            map.fitBounds(bounds, { padding: [50, 50] });
        } else {
            alert(`No se encontraron paradas para la l칤nea ${lineIdInput}.`);
        }
    }

    let currentTripShapeData = new Map(); // Cache para los datos de forma

    async function mostrarRecorrido(tripId, shapeId) {
        clearMapElements();
        document.getElementById('stop-results').style.display = 'none';
        document.getElementById('route-details').style.display = 'block';

        const trip = tripsData.get(tripId);
        if (!trip) {
            console.error("Trip ID no encontrado:", tripId);
            return alert("Error: Informaci칩n del viaje no disponible.");
        }
        document.getElementById('route-details').querySelector('h2').textContent = `Recorrido: L칤nea ${trip.route_id} - ${trip.trip_headsign}`;

        const stopsOnRoute = stopTimesData
            .filter(st => st.trip_id === tripId)
            .sort((a, b) => a.stop_sequence - b.stop_sequence);

        if (stopsOnRoute.length === 0) {
            return alert("No se encontraron paradas para este recorrido.");
        }

        let mapElementsBounds = new L.LatLngBounds();

        // Mostrar puntos de la forma (ruta)
        if (shapeId) {
            let shapeCoords = currentTripShapeData.get(shapeId);
            if (!shapeCoords) {
                try {
                    const shapeResp = await fetch(`data/shapes.txt`);
                    const shapeText = await shapeResp.text();
                    const lines = shapeText.split('\n');
                    const header = lines[0].split(',');
                    const shapeIdIndex = header.indexOf('shape_id');
                    const latIndex = header.indexOf('shape_pt_lat');
                    const lonIndex = header.indexOf('shape_pt_lon');

                    const filteredCoords = [];
                    for (let i = 1; i < lines.length; i++) {
                        const parts = lines[i].split(',');
                        if (parts[shapeIdIndex] === shapeId) {
                            filteredCoords.push([parseFloat(parts[latIndex]), parseFloat(parts[lonIndex])]);
                        }
                    }
                    shapeCoords = filteredCoords;
                    currentTripShapeData.set(shapeId, shapeCoords);
                } catch (error) {
                    console.error("Error cargando datos de forma:", error);
                    shapeCoords = [];
                }
            }
            if (shapeCoords.length > 0) {
                routePolyline = L.polyline(shapeCoords, { color: 'blue', weight: 4, opacity: 0.7 }).addTo(map);
                mapElementsBounds.extend(routePolyline.getBounds());
            }
        }

        // A침adir marcadores para cada parada en el recorrido
        stopsOnRoute.forEach(st => {
            const stopInfo = stopsData.get(st.stop_id);
            if (stopInfo) {
                const marker = L.marker([stopInfo.stop_lat, stopInfo.stop_lon]).addTo(map);
                marker.bindPopup(`<b>Parada:</b> ${getCleanStopName(st.stop_id)} (${st.stop_id})<br>Programado: ${st.arrival_time}`);
                markers.push(marker);
                mapElementsBounds.extend(marker.getLatLng());
            }
        });

        // Localizar el bus en tiempo real
        // currentBusDelayInSeconds y currentBusStopIdRealTime se actualizan aqu칤
        await localizarBusEnTiempoReal(tripId, stopsOnRoute);

        // Renderizar la lista de paradas del recorrido
        const stopListBounds = renderRouteStopList(tripId, stopsOnRoute);
        if (stopListBounds.isValid()) {
            mapElementsBounds.extend(stopListBounds);
        }

        // Ajustar el mapa para que se vean todos los elementos
        if (mapElementsBounds.isValid()) {
            map.fitBounds(mapElementsBounds, { padding: [50, 50] });
        }
    }


    async function localizarBusEnTiempoReal(tripId, stopsOnRoute) {
        currentBusDelayInSeconds = null;
        currentBusStopIdRealTime = null;
        if (realTimeBusMarker) {
            map.removeLayer(realTimeBusMarker);
            realTimeBusMarker = null;
        }

        const delayInfoDiv = document.getElementById('delay-info');
        delayInfoDiv.textContent = 'Buscando datos en tiempo real...';

        try {
            const response = await fetch("https://bizkaibus.onrender.com/bizkaibus");
            const xmlText = await response.text();
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "application/xml");

            const vehicleActivities = xmlDoc.getElementsByTagName("VehicleActivity");
            let foundLiveBus = null;

            for (let i = 0; i < vehicleActivities.length; i++) {
                const activity = vehicleActivities[i];
                const vehicleJourneyRef = activity.querySelector("VehicleJourneyRef")?.textContent.trim();
                if (vehicleJourneyRef === tripId) {
                    foundLiveBus = activity;
                    break;
                }
            }

            if (foundLiveBus) {
                const recordedAtTime = foundLiveBus.querySelector("RecordedAtTime")?.textContent.trim();
                const vehicleRef = foundLiveBus.querySelector("VehicleRef")?.textContent.trim();
                const lon = parseFloat(foundLiveBus.querySelector("Longitude")?.textContent.trim());
                const lat = parseFloat(foundLiveBus.querySelector("Latitude")?.textContent.trim());
                const bearing = parseFloat(foundLiveBus.querySelector("Bearing")?.textContent.trim());
                const delayStr = foundLiveBus.querySelector("Delay")?.textContent.trim(); // Formato PTxM

                const stopPointRef = foundLiveBus.querySelector("StopPointRef")?.textContent.trim();
                currentBusStopIdRealTime = stopPointRef;

                if (lat && lon) {
                    realTimeBusMarker = L.marker([lat, lon], {
                        icon: L.icon({
                            iconUrl: 'https://cdn-icons-png.flaticon.com/512/168/168759.png', // Icono de bus
                            iconSize: [32, 32],
                            iconAnchor: [16, 16]
                        }),
                        rotationAngle: bearing || 0 // Usar el bearing si est치 disponible
                    }).addTo(map);

                    let delaySeconds = 0;
                    if (delayStr && delayStr.startsWith("PT") && delayStr.endsWith("M")) {
                        const minutes = parseInt(delayStr.substring(2, delayStr.length - 1));
                        delaySeconds = minutes * 60;
                    }

                    currentBusDelayInSeconds = delaySeconds;

                    let delayText = "";
                    let delayClass = "";

                    if (delaySeconds > 90) { // M치s de 1.5 minutos de retraso
                        delayText = `Retraso: +${Math.round(delaySeconds / 60)}m`;
                        delayClass = "delay";
                    } else if (delaySeconds < -90) { // M치s de 1.5 minutos de adelanto
                        delayText = `Adelanto: ${Math.round(delaySeconds / 60)}m`; // Ya incluye el signo negativo
                        delayClass = "advance";
                    } else {
                        delayText = "En hora";
                        delayClass = "on-time";
                    }
                    delayInfoDiv.innerHTML = `Bus: ${vehicleRef} - Estado: <span class="delay-text ${delayClass}">${delayText}</span>`;
                    
                    // Aseg칰rate de que el popup del marcador del bus en tiempo real se actualice
                    const stopInfoAtRealTime = stopsData.get(stopPointRef);
                    let stopNameAtRealTime = stopPointRef;
                    if (stopInfoAtRealTime) {
                        stopNameAtRealTime = getCleanStopName(stopPointRef);
                    }
                    realTimeBusMarker.bindPopup(`<b>Bus:</b> ${vehicleRef}<br>Estado: ${delayText}<br>칔ltima posici칩n cerca de: ${stopNameAtRealTime}`).openPopup();

                    // Ajustar la vista si es necesario
                    map.setView(realTimeBusMarker.getLatLng(), map.getZoom() < 14 ? 14 : map.getZoom());

                } else {
                    delayInfoDiv.textContent = "Datos de posici칩n (lat/lon) no disponibles para este bus en tiempo real.";
                }
            } else {
                delayInfoDiv.textContent = "Datos en tiempo real no disponibles para este viaje.";
            }
        } catch (error) {
            console.error("Error al obtener datos en tiempo real:", error);
            delayInfoDiv.textContent = "Error al conectar con el servicio de tiempo real.";
            currentBusDelayInSeconds = null; // Resetear en caso de error
            currentBusStopIdRealTime = null;
        }
    }

    function renderRouteStopList(tripId, stopsOnRoute) {
        const routeStopList = document.getElementById('route-stop-list');
        routeStopList.innerHTML = ""; 
        let listBounds = new L.LatLngBounds(); 

        stopsOnRoute.forEach(st => {
            const stopInfo = stopsData.get(st.stop_id);
            if (stopInfo) {
                const paradaTexto = getCleanStopName(st.stop_id);
                const li = document.createElement("li");

                let estimatedTimeHtml = "";
                // CAMBIO: No mostrar la hora estimada si el bus va en hora (retraso/adelanto <= 15 segundos)
                if (currentBusDelayInSeconds !== null && Math.abs(currentBusDelayInSeconds) > 90) { // Usamos 90 segundos (1.5min) como umbral para mostrar estimada
                    const scheduledSeconds = timeToSeconds(st.arrival_time);
                    if (scheduledSeconds > 0) {
                        const estimatedSeconds = scheduledSeconds + currentBusDelayInSeconds;
                        const estimatedTimeStr = secondsToTime(estimatedSeconds).substring(0,5); // Mostrar HH:MM
                        estimatedTimeHtml = ` <span class="estimated-time">(Est: ${estimatedTimeStr})</span>`;
                    }
                }
                
                let waypointIconHtml = "";
                if (currentBusStopIdRealTime && st.stop_id === currentBusStopIdRealTime) {
                    waypointIconHtml = ` <span class="waypoint-icon" title="Ubicaci칩n actual/pr칩xima reportada">游늸</span>`;
                }
                
                li.innerHTML = `<span class="scheduled-time">${st.arrival_time.substring(0,5)}</span>${estimatedTimeHtml} - ${paradaTexto} (${st.stop_id})${waypointIconHtml}`;  
                routeStopList.appendChild(li);
                listBounds.extend([stopInfo.stop_lat, stopInfo.stop_lon]); 
            }
        });
        return listBounds; 
    }

    window.onload = async () => {
      await Promise.all([cargarDatosGTFS()]); // Solo carga GTFS al inicio
      document.getElementById('stop-results').style.display = 'none';
      document.getElementById('route-details').style.display = 'none';
      document.getElementById('delay-info').textContent = ''; 
    };
  </script>
</body>
</html>
