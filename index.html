<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Bizkaibus en Tiempo Real</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 1em;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5em;
      margin-bottom: 1em;
    }
    input {
      padding: 0.5em; font-size: 1em;
      width: 300px; max-width: 90vw; box-sizing: border-box;
    }
    button {
      padding: 0.5em 1em; font-size: 1em; cursor: pointer;
    }
    #map {
      height: 80vh;
      width: 100%; max-width: 1750px;
    }
    #stop-results {
      margin-top: 1em;
      width: 100%;
      max-width: 1750px;
      text-align: left;
    }
    #stop-results h2 {
      margin-top: 0;
    }
    .bus-option {
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      padding: 0.5em;
      margin-bottom: 0.5em;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .bus-option:hover {
      background-color: #e0e0e0;
    }
    .bus-option span {
      font-weight: bold;
    }
    #route-details {
      margin-top: 1em;
      width: 100%;
      max-width: 1750px;
      text-align: left;
      border: 1px solid #ccc;
      padding: 1em;
      box-sizing: border-box;
    }
    #route-details ul {
      list-style-type: none;
      padding: 0;
    }
    #route-details li {
      margin-bottom: 0.2em;
      padding: 0.3em;
      border-bottom: 1px dashed #eee;
    }
    #route-details li:last-child {
        border-bottom: none;
    }
    .scheduled-time {
        font-weight: bold;
    }
    .estimated-time {
        color: #d9534f; /* Un color rojo suave para la estimación */
        font-style: italic;
        margin-left: 5px;
    }
  </style>
</head>
<body>
  <h1>Localizador de Autobuses Bizkaibus</h1>
  <div id="controls">
    <input type="text" id="linea" placeholder="Introduce nº de línea (ej: A3935 o 3935)" />
    <button onclick="buscarBusesPorLinea()">Buscar Línea</button>
    <input type="text" id="parada" placeholder="Introduce nº de parada (ej: 123)" />
    <button onclick="buscarBusesPorParada()">Buscar Parada</button>
    <input type="text" id="numBus" placeholder="Introduce nº de bus (ej: 1514)" />
    <button onclick="buscarBusPorNumero()">Buscar Bus</button>
  </div>
  <div id="stop-results">
    <h2>Próximos autobuses en la parada:</h2>
    <div id="bus-list"></div>
  </div>
  <div id="route-details" style="display: none;">
    <h2>Detalles del recorrido: <span id="route-line-name"></span></h2>
    <p>Dirección: <span id="route-headsign"></span></p>
    <p id="delay-info" style="font-weight:bold;"></p> <ul id="route-stop-list"></ul>
  </div>
  <div id="map"></div>
  
  <script>
    // Autenticación básica por prompt
    const USUARIO = "admin";
    const CONTRASENA = "bizkaibus123";

    function autenticar() {
      const yaAutenticado = localStorage.getItem("autenticado");

      if (yaAutenticado === "true") {
        console.log("Autenticación exitosa (desde localStorage).");
        return;
      }

      const u = prompt("Usuario:");
      const p = prompt("Contraseña:");

      if (u === USUARIO && p === CONTRASENA) {
        localStorage.setItem("autenticado", "true");
        console.log("Autenticación exitosa (nueva).");
      } else {
        alert("Acceso denegado. Recarga la página para intentarlo de nuevo.");
        document.body.innerHTML = "<h1>401 No autorizado</h1><p>Por favor, recarga la página e introduce las credenciales correctas.</p>";
        throw new Error("Acceso denegado");
      }
    }
    autenticar();
  </script>
  
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // URL de tu hoja publicada como TSV
    const SHEET_TSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTYeZkna4mwxp3p2azwTgAPcjeSBoUU_rhWW5gVZ7hqotNtojQOHtsjbEnnlJbrijBVwck_kWERE__6/pub?output=tsv"; // URL ACTUALIZADA

    // URLs de los archivos GTFS proporcionados por el usuario
    const STOPS_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/main/stops.txt";
    const STOP_TIMES1_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/main/stop_times1.txt";
    const STOP_TIMES2_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/main/stop_times2.txt";
    const STOP_TIMES3_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/main/stop_times3.txt";
    const TRIPS_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/main/trips.txt";
    const CALENDAR_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/main/calendar.txt";
    const CALENDAR_DATES_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibusparadas/main/calendar_dates.txt";

    let map = L.map("map").setView([43.25, -2.93], 10);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "© OpenStreetMap",
    }).addTo(map);

    let markers = [];
    let stopMarkers = []; 
    let realTimeBusMarker = null; 
    let linePolylines = [];

    let stopsData = new Map();
    let busInfoMap = new Map();
    let stopTimesData = [];
    let tripsData = new Map();
    let calendarData = new Map();
    let calendarDatesData = new Map();

    // NUEVO: Variable para almacenar el retraso actual del bus en segundos
    let currentBusDelayInSeconds = null; 

    const COLORS = ['#FF0000', '#0000FF', '#008000', '#FFA500', '#800080', '#00FFFF', '#FF00FF', '#808080'];

    const busIcon = L.icon({
        iconUrl: 'https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
    });
    
    // NUEVO: Funciones auxiliares para manejar tiempos
    function timeToSeconds(timeStr) {
        if (!timeStr || !/^\d{2}:\d{2}:\d{2}$/.test(timeStr)) return 0;
        const parts = timeStr.split(':');
        return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);
    }

    function secondsToTime(totalSeconds) {
        if (totalSeconds === null || isNaN(totalSeconds)) return "N/A";
        
        // Manejar días siguientes si el retraso es muy grande (poco probable pero seguro)
        const secondsInDay = 24 * 60 * 60;
        let days = Math.floor(totalSeconds / secondsInDay);
        let remainingSeconds = totalSeconds % secondsInDay;

        // Si los segundos son negativos (adelanto que cruza la medianoche hacia atrás)
        if (remainingSeconds < 0) {
            remainingSeconds += secondsInDay;
            days -=1; // Se fue al día anterior
        }
        
        const h = Math.floor(remainingSeconds / 3600);
        const m = Math.floor((remainingSeconds % 3600) / 60);
        const s = remainingSeconds % 60;
        
        let timeString = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        if (days > 0) {
            timeString += ` (+${days}d)`;
        } else if (days < 0) {
            timeString += ` (${days}d)`; // ej. (-1d) si se adelanta mucho
        }
        return timeString;
    }


    async function cargarDatosGTFS() {
      try {
        console.log("Iniciando carga de stops.txt desde:", STOPS_URL);
        const resStops = await fetch(STOPS_URL);
        const textStops = await resStops.text();
        const rowsStops = textStops.trim().split("\n").map(row => row.split(","));
        
        rowsStops.slice(1).forEach(row => {
          const stop_id = row[0]?.trim();
          if (stop_id && row.length >= 6) {  
              stopsData.set(stop_id, {
                stop_name: row[2]?.trim(),
                stop_lat: parseFloat(row[4]),
                stop_lon: parseFloat(row[5]),
              });
          } else {
              console.warn("Skipping malformed or incomplete row in stops.txt:", row);
          }
        });
        console.log("stopsData map size after loading:", stopsData.size);

        const stopTimesPromises = [
            fetch(STOP_TIMES1_URL).then(res => res.text()),
            fetch(STOP_TIMES2_URL).then(res => res.text()),
            fetch(STOP_TIMES3_URL).then(res => res.text())
        ];
        const stopTimesTexts = await Promise.all(stopTimesPromises);

        stopTimesTexts.forEach(text => {
            const rowsStopTimes = text.trim().split("\n").map(row => row.split(","));
            rowsStopTimes.slice(1).forEach(row => {
                if (row.length >= 5) {
                    stopTimesData.push({
                        trip_id: row[0]?.trim(),
                        arrival_time: row[1]?.trim(),
                        departure_time: row[2]?.trim(),
                        stop_id: row[3]?.trim(),
                        stop_sequence: parseInt(row[4]),
                    });
                }
            });
        });
        console.log("Total stopTimes loaded:", stopTimesData.length);

        const resTrips = await fetch(TRIPS_URL);
        const textTrips = await resTrips.text();
        const rowsTrips = textTrips.trim().split("\n").map(row => row.split(","));
        rowsTrips.slice(1).forEach(row => {
          if (row.length >= 8) {
              tripsData.set(row[2]?.trim(), {
                route_id: row[0]?.trim(),
                service_id: row[1]?.trim(),
                trip_headsign: row[3]?.trim(),
                shape_id: row[7]?.trim(),
              });
          }
        });
        console.log("Total trips loaded:", tripsData.size);

        const resCalendar = await fetch(CALENDAR_URL);
        const textCalendar = await resCalendar.text();
        const rowsCalendar = textCalendar.trim().split("\n").map(row => row.split(","));
        rowsCalendar.slice(1).forEach(row => {
            if (row.length >= 10) {
                calendarData.set(row[0]?.trim(), {
                    monday: parseInt(row[1]),
                    tuesday: parseInt(row[2]),
                    wednesday: parseInt(row[3]),
                    thursday: parseInt(row[4]),
                    friday: parseInt(row[5]),
                    saturday: parseInt(row[6]),
                    sunday: parseInt(row[7]),
                    start_date: row[8]?.trim(),
                    end_date: row[9]?.trim()
                });
            }
        });
        console.log("Total calendar services loaded:", calendarData.size);

        const resCalendarDates = await fetch(CALENDAR_DATES_URL);
        const textCalendarDates = await resCalendarDates.text();
        const rowsCalendarDates = textCalendarDates.trim().split("\n").map(row => row.split(","));
        rowsCalendarDates.slice(1).forEach(row => {
            if (row.length >= 3) {
                const service_id = row[0]?.trim();
                const date = row[1]?.trim();
                const exception_type = parseInt(row[2]);

                if (!calendarDatesData.has(service_id)) {
                    calendarDatesData.set(service_id, new Map());
                }
                calendarDatesData.get(service_id).set(date, exception_type);
            }
        });
        console.log("Total calendar_dates loaded (unique service_id with exceptions):", calendarDatesData.size);

      } catch (e) {
        console.error("Error cargando datos GTFS:", e);
      }
    }

    async function cargarBusInfo() {
      try {
        const res = await fetch(SHEET_TSV_URL);
        const tsv = await res.text();
        const filas = tsv.trim().split("\n").map(r => r.split("\t"));
        filas.slice(1).forEach(fila => {
          const num = fila[0]?.trim();
          if (num) {
            busInfoMap.set(num, {
              matricula: fila[1]?.trim() || "—",
              modelo: fila[2]?.trim() || "—",
              fecha: fila[3]?.trim() || "—"
            });
          }
        });
        console.log("Total bus info loaded:", busInfoMap.size);

      } catch (e) {
        console.error("Error cargando busInfo:", e);
      }
    }

    function getCleanStopName(stopId) {
        const stopInfo = stopsData.get(stopId);
        if (stopInfo) {
            const name = stopInfo.stop_name;
            const regex = new RegExp(`\\s*\\(${stopId}\\)$`);
            return name.replace(regex, '');
        }
        return "Desconocida";
    }

    function extraerNumero(texto) {
      const m = texto.match(/\d+/);
      return m ? m[0] : null;
    }

    function clearMapElements() {
        currentBusDelayInSeconds = null; // NUEVO: Resetear retraso
        document.getElementById('delay-info').textContent = ''; // NUEVO: Limpiar info de retraso

        if (realTimeBusMarker) {
            map.removeLayer(realTimeBusMarker);
            realTimeBusMarker = null;
        }
        linePolylines.forEach(poly => map.removeLayer(poly));
        linePolylines = [];
        stopMarkers.forEach(m => map.removeLayer(m));
        stopMarkers = [];
    }
    
    function clearLineSearchMarkers() {
        markers.forEach(m => map.removeLayer(m));
        markers = []; 
    }

    async function buscarBusesPorLinea() {
      const inputRaw = document.getElementById("linea").value.trim();
      if (!inputRaw) return alert("Introduce un número de línea válido");

      const input = inputRaw.toUpperCase();
      const inputNum = extraerNumero(inputRaw);

      clearMapElements(); 
      clearLineSearchMarkers(); 

      document.getElementById('stop-results').style.display = 'none';
      document.getElementById('route-details').style.display = 'none';
      currentBusDelayInSeconds = null; // NUEVO: Resetear retraso
      document.getElementById('delay-info').textContent = ''; // NUEVO: Limpiar info de retraso


      try {
        const resp = await fetch("https://bizkaibus.onrender.com/bizkaibus");
        const xmlText = await resp.text();
        const xml = new DOMParser().parseFromString(xmlText, "application/xml");
        const actividades = xml.getElementsByTagName("VehicleActivity");
        let encontrados = 0;
        let bounds = new L.LatLngBounds();

        for (let act of actividades) {
          const jref = act.querySelector("VehicleJourneyRef")?.textContent.trim().toUpperCase();
          const vref = act.querySelector("VehicleRef")?.textContent.trim();
          const lat = parseFloat(act.querySelector("Latitude")?.textContent);
          const lon = parseFloat(act.querySelector("Longitude")?.textContent);
          const sp = act.querySelector("StopPointRef")?.textContent.trim();

          if (!jref || !vref || isNaN(lat) || isNaN(lon)) continue;

          const match = jref.match(/A\d{3,4}/);
          const lineaLimpia = match ? match[0] : jref;
          const lineaNum = extraerNumero(lineaLimpia);
          const coincide = (
            lineaLimpia === input ||
            (inputNum && lineaNum === inputNum)
          );
          if (!coincide) continue;

          const paradaTexto = getCleanStopName(sp);
          const infoBus = busInfoMap.get(vref) || { matricula: "—", modelo: "—", fecha: "—"};

          const marcador = L.marker([lat, lon]).addTo(map);
          marcador.bindPopup(`
            <b>Línea:</b> ${lineaLimpia}<br>
            <b>Parada:</b> ${paradaTexto} (${sp})<br>
            <b>Bus:</b> ${vref}<br>
            <b>Matrícula:</b> ${infoBus.matricula}<br>
            <b>Modelo:</b> ${infoBus.modelo}<br>
            <b>Fecha matriculación:</b> ${infoBus.fecha}
          `);
          markers.push(marcador);
          bounds.extend([lat, lon]);
          encontrados++;
        }

        if (!encontrados) {
          alert("No se encontraron buses en tiempo real para esa línea.");
        } else {
            map.fitBounds(bounds, { padding: [50, 50] });
        }
      } catch (e) {
        console.error("Error en buscarBusesPorLinea:", e);
        alert("Error al descargar o procesar datos de Bizkaibus.");
      }
    }

    async function buscarBusesPorParada() {
        const stopIdInput = document.getElementById("parada").value.trim();
        if (!stopIdInput) {
            return alert("Introduce un número de parada válido.");
        }

        const stopId = stopIdInput;
        
        if (!stopsData.has(stopId)) {
            console.error(`La parada con ID "${stopId}" NO se encontró en stopsData.`);
            return alert("Parada no encontrada. Introduce un ID de parada válido.");
        }

        clearLineSearchMarkers();
        clearMapElements();  

        document.getElementById('route-details').style.display = 'none';
        currentBusDelayInSeconds = null; // NUEVO: Resetear retraso
        document.getElementById('delay-info').textContent = ''; // NUEVO: Limpiar info de retraso

        const busListDiv = document.getElementById("bus-list");
        busListDiv.innerHTML = "Cargando próximos autobuses...";
        document.getElementById('stop-results').style.display = 'block';
        document.getElementById('stop-results').querySelector('h2').textContent = `Próximos autobuses en parada: ${getCleanStopName(stopId)} (${stopId})`;


        const now = new Date();
        const currentDayOfWeek = now.getDay(); // 0 (Domingo) a 6 (Sábado)
        const currentYear = now.getFullYear();
        const currentMonth = (now.getMonth() + 1).toString().padStart(2, '0');
        const currentDay = now.getDate().toString().padStart(2, '0');
        const currentDate = `${currentYear}${currentMonth}${currentDay}`;
        const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;

        const upcomingBuses = [];
        const stopTimesAtThisStop = stopTimesData.filter(st => st.stop_id === stopId);

        for (const st of stopTimesAtThisStop) {
            const trip = tripsData.get(st.trip_id);
            if (!trip) continue;

            const service = calendarData.get(trip.service_id);
            if (!service) continue;

            const serviceStartDate = parseInt(service.start_date);
            const serviceEndDate = parseInt(service.end_date);
            const currentFormattedDate = parseInt(currentDate);

            if (currentFormattedDate < serviceStartDate || currentFormattedDate > serviceEndDate) {
                continue; 
            }

            const serviceExceptions = calendarDatesData.get(trip.service_id);
            const currentException = serviceExceptions ? serviceExceptions.get(currentDate) : undefined;

            let runsToday = false;

            if (currentException === 1) { // Servicio añadido para esta fecha
                runsToday = true;
            } else if (currentException === 2) { // Servicio eliminado para esta fecha
                runsToday = false;
            } else { // Comprobar día de la semana normal
                switch (currentDayOfWeek) {
                    case 0: runsToday = service.sunday === 1; break; // Domingo
                    case 1: runsToday = service.monday === 1; break;
                    case 2: runsToday = service.tuesday === 1; break;
                    case 3: runsToday = service.wednesday === 1; break;
                    case 4: runsToday = service.thursday === 1; break;
                    case 5: runsToday = service.friday === 1; break;
                    case 6: runsToday = service.saturday === 1; break;
                }
            }
            
            if (!runsToday) continue;

            if (st.departure_time > currentTime) {
                upcomingBuses.push({
                    linea: trip.route_id,
                    hora: st.departure_time,
                    destino: trip.trip_headsign,
                    trip_id: st.trip_id,
                    shape_id: trip.shape_id 
                });
            }
        }

        upcomingBuses.sort((a, b) => a.hora.localeCompare(b.hora));

        busListDiv.innerHTML = "";
        if (upcomingBuses.length > 0) {
            const stopInfo = stopsData.get(stopId);
            if (stopInfo) {
                const paradaTexto = getCleanStopName(stopId);
                const stopMarker = L.marker([stopInfo.stop_lat, stopInfo.stop_lon]).addTo(map);
                stopMarker.bindPopup(`<b>Parada:</b> ${paradaTexto} (${stopId})`).openPopup();
                // MODIFICADO: usamos stopMarkers para poder limpiarlos selectivamente
                stopMarkers.push(stopMarker); 
                map.setView([stopInfo.stop_lat, stopInfo.stop_lon], 15);
            }

            upcomingBuses.slice(0, 10).forEach(bus => {
                const busOption = document.createElement("div");
                busOption.classList.add("bus-option");
                busOption.innerHTML = `
                    <span>Línea: ${bus.linea}</span>
                    <span>Hora: ${bus.hora}</span>
                    <span>Destino: ${bus.destino}</span>
                `;
                busOption.onclick = () => {
                    console.log("Trip ID seleccionado:", bus.trip_id);
                    mostrarRecorrido(bus.trip_id, bus.shape_id); 
                };
                busListDiv.appendChild(busOption);
            });
        } else {
            busListDiv.innerHTML = "<p>No hay próximos autobuses programados para esta parada hoy.</p>";
        }
    }

    async function localizarBusEnTiempoReal(targetTripId = null, targetVehicleRef = null) {
        currentBusDelayInSeconds = null; // NUEVO: Resetear retraso al inicio de cada localización
        document.getElementById('delay-info').textContent = ''; // NUEVO: Limpiar info de retraso

        if (!targetTripId && !targetVehicleRef) {
            console.error("localizarBusEnTiempoReal: Se requiere targetTripId o targetVehicleRef.");
            // No alertar aquí, ya que puede ser una llamada interna
            return null; 
        }

        if (realTimeBusMarker) {
            map.removeLayer(realTimeBusMarker);
            realTimeBusMarker = null;
        }

        try {
            const resp = await fetch("https://bizkaibus.onrender.com/bizkaibus");
            const xmlText = await resp.text();
            const xml = new DOMParser().parseFromString(xmlText, "application/xml");
            const actividades = xml.getElementsByTagName("VehicleActivity");

            let busEncontrado = false;
            let currentBusLat, currentBusLon;
            let foundTripIdForBus = null;

            for (let act of actividades) {
                const jref = act.querySelector("VehicleJourneyRef")?.textContent.trim(); 
                const vref = act.querySelector("VehicleRef")?.textContent.trim(); 
                const lat = parseFloat(act.querySelector("Latitude")?.textContent);
                const lon = parseFloat(act.querySelector("Longitude")?.textContent);
                const spRef = act.querySelector("StopPointRef")?.textContent.trim();
                // NUEVO: Obtener RecordedAtTime para cálculo de retraso
                const recordedAtTimeISO = act.querySelector("RecordedAtTime")?.textContent.trim();


                if (!isNaN(lat) && !isNaN(lon)) {
                    const condicionCumplida = 
                        (targetTripId && jref === targetTripId) ||
                        (targetVehicleRef && vref === targetVehicleRef);

                    if (condicionCumplida) {
                        const infoBus = busInfoMap.get(vref) || { matricula: "—", modelo: "—", fecha: "—"};
                        const paradaActualNombre = getCleanStopName(spRef);

                        let lineaDisplay = 'N/A';
                        let destinoDisplay = 'N/A';
                        if (jref && tripsData.has(jref)) {
                            lineaDisplay = tripsData.get(jref).route_id || 'N/A';
                            destinoDisplay = tripsData.get(jref).trip_headsign || 'N/A';
                        }
                        
                        realTimeBusMarker = L.marker([lat, lon], { icon: busIcon }).addTo(map);
                        realTimeBusMarker.bindPopup(`
                            <b>¡Autobús en tiempo real!</b><br>
                            <b>Línea:</b> ${lineaDisplay}<br>
                            <b>Destino:</b> ${destinoDisplay}<br>
                            <b>Ref. Parada actual/sig:</b> ${paradaActualNombre} (${spRef || 'N/A'})<br>
                            <b>Bus Nº:</b> ${vref}<br>
                            <b>Matrícula:</b> ${infoBus.matricula}<br>
                            <b>Modelo:</b> ${infoBus.modelo}<br>
                        `).openPopup();
                        
                        busEncontrado = true;
                        currentBusLat = lat;
                        currentBusLon = lon;
                        foundTripIdForBus = jref; 

                        // --- NUEVO: Cálculo del retraso ---
                        if (recordedAtTimeISO && spRef && jref) {
                            const tripStopTimes = stopTimesData.filter(st => st.trip_id === jref && st.stop_id === spRef);
                            if (tripStopTimes.length > 0) {
                                const scheduledArrivalTimeStr = tripStopTimes[0].arrival_time; // Asumimos la primera coincidencia
                                const scheduledArrivalSeconds = timeToSeconds(scheduledArrivalTimeStr);
                                
                                // Extraer HH:MM:SS de la fecha ISO (asumimos que es hora local o comparable)
                                const realTimeDate = new Date(recordedAtTimeISO);
                                const realTimeStr = `${realTimeDate.getHours().toString().padStart(2, '0')}:${realTimeDate.getMinutes().toString().padStart(2, '0')}:${realTimeDate.getSeconds().toString().padStart(2, '0')}`;
                                const realTimeSeconds = timeToSeconds(realTimeStr);

                                if (scheduledArrivalSeconds > 0 && realTimeSeconds > 0) {
                                    currentBusDelayInSeconds = realTimeSeconds - scheduledArrivalSeconds;
                                    console.log(`Retraso calculado para bus ${vref} (trip ${jref}) en parada ${spRef}: ${currentBusDelayInSeconds}s. Real: ${realTimeStr}, Prog: ${scheduledArrivalTimeStr}`);
                                    
                                    const delayInfoEl = document.getElementById('delay-info');
                                    if (currentBusDelayInSeconds > 60) {
                                        delayInfoEl.textContent = `Retraso estimado: ${Math.round(currentBusDelayInSeconds / 60)} minutos.`;
                                        delayInfoEl.style.color = 'red';
                                    } else if (currentBusDelayInSeconds < -60) {
                                        delayInfoEl.textContent = `Adelanto estimado: ${Math.round(Math.abs(currentBusDelayInSeconds) / 60)} minutos.`;
                                        delayInfoEl.style.color = 'green';
                                    } else if (currentBusDelayInSeconds !== 0) {
                                        delayInfoEl.textContent = `En hora (aprox. ${currentBusDelayInSeconds}s ${currentBusDelayInSeconds > 0 ? 'tarde' : 'pronto'}).`;
                                        delayInfoEl.style.color = 'orange';
                                    } else {
                                        delayInfoEl.textContent = "En hora (según última actualización).";
                                        delayInfoEl.style.color = 'green';
                                    }
                                } else {
                                   console.warn("No se pudo calcular el retraso: tiempos inválidos.", {scheduledArrivalTimeStr, realTimeStr});
                                }
                            } else {
                                console.warn(`No se encontró el stop_time para trip ${jref} y stop ${spRef} para calcular retraso.`);
                            }
                        }
                        // --- FIN NUEVO: Cálculo del retraso ---
                        break; 
                    }
                }
            }

            if (!busEncontrado) {
                let msg = `No se encontró el autobús`;
                if (targetTripId) msg += ` con el trip ID ${targetTripId}`;
                if (targetVehicleRef) msg += ` con el número ${targetVehicleRef}`;
                msg += ` en tiempo real.`;
                // No mostramos alert aquí, podría ser una búsqueda interna
                console.warn(msg);
                currentBusDelayInSeconds = null; // Asegurar que está nulo
                document.getElementById('delay-info').textContent = 'Autobús no localizado en tiempo real.';
                document.getElementById('delay-info').style.color = 'black';
                return null;
            } else {
                let currentBounds = map.getBounds();
                if (!currentBounds.contains([currentBusLat, currentBusLon])) {
                     // Solo centrar si el bus no está visible junto con el recorrido, si ya hay uno
                    if (!linePolylines.length > 0) { // Si no hay polilínea de recorrido, centrar en el bus
                        map.setView([currentBusLat, currentBusLon], 15);
                    } else { // Si hay recorrido, intentar extender los bounds para incluirlo
                        let routeBounds = linePolylines[0].getBounds(); // Asumimos una polilínea principal
                        routeBounds.extend([currentBusLat, currentBusLon]);
                        map.fitBounds(routeBounds, { padding: [70, 70]});
                    }
                }
                return foundTripIdForBus; // Retornar el trip_id del bus encontrado
            }

        } catch (e) {
            console.error("Error al localizar el bus en tiempo real:", e);
            alert("Error al intentar obtener la ubicación en tiempo real del autobús.");
            currentBusDelayInSeconds = null; // Asegurar
            document.getElementById('delay-info').textContent = 'Error obteniendo datos en tiempo real.';
            document.getElementById('delay-info').style.color = 'black';
            return null;
        }
    }


    async function buscarBusPorNumero() {
        const numBus = document.getElementById("numBus").value.trim();
        if (!numBus) {
            alert("Introduce un número de bus válido.");
            return;
        }

        clearMapElements();
        clearLineSearchMarkers();
        document.getElementById('stop-results').style.display = 'none';
        document.getElementById('route-details').style.display = 'none'; // Ocultar detalles por defecto
        currentBusDelayInSeconds = null; // NUEVO: Resetear retraso
        document.getElementById('delay-info').textContent = '';


        const foundTripId = await localizarBusEnTiempoReal(null, numBus);

        if (foundTripId) {
            const tripInfo = tripsData.get(foundTripId);
            if (tripInfo) {
                // mostrarRecorrido ahora usará el currentBusDelayInSeconds calculado en localizarBusEnTiempoReal
                mostrarRecorrido(foundTripId, tripInfo.shape_id);
            } else {
                console.warn(`Trip ID ${foundTripId} encontrado para el bus ${numBus}, pero no se encontraron sus detalles en tripsData.`);
                alert(`Se encontró el bus ${numBus} pero no se pudo cargar su recorrido completo (faltan datos del viaje).`);
                document.getElementById('route-details').style.display = 'none';
            }
        } else {
             document.getElementById('route-details').style.display = 'none'; // Asegurar que está oculto si no se encuentra
        }
    }


    async function mostrarRecorrido(tripId, shapeId) {
        clearLineSearchMarkers();
        // No limpiar todo el mapa aquí, solo paradas y polilíneas previas de *otro* recorrido.
        // El bus en tiempo real (realTimeBusMarker) se gestiona por localizarBusEnTiempoReal
        stopMarkers.forEach(m => map.removeLayer(m));
        stopMarkers = [];
        linePolylines.forEach(poly => map.removeLayer(poly));
        linePolylines = [];
        // No borramos realTimeBusMarker aquí, localizarBusEnTiempoReal se encarga
        // y necesitamos la información de currentBusDelayInSeconds que pudo haber establecido.

        document.getElementById('stop-results').style.display = 'none';
        document.getElementById('route-details').style.display = 'block';

        const trip = tripsData.get(tripId);
        if (!trip) {
            alert("Información del viaje no encontrada.");
            document.getElementById('route-details').style.display = 'none';
            return;
        }

        document.getElementById('route-line-name').textContent = trip.route_id;
        document.getElementById('route-headsign').textContent = trip.trip_headsign;
        const routeStopList = document.getElementById('route-stop-list');
        routeStopList.innerHTML = "";

        const stopsOnRoute = stopTimesData
            .filter(st => st.trip_id === tripId)
            .sort((a, b) => a.stop_sequence - b.stop_sequence);

        let bounds = new L.LatLngBounds();
        let polylinePoints = [];

        for (const st of stopsOnRoute) {
            const stopInfo = stopsData.get(st.stop_id);
            if (stopInfo) {
                const paradaTexto = getCleanStopName(st.stop_id);
                const li = document.createElement("li");

                // MODIFICADO: Añadir hora estimada si hay retraso
                let estimatedTimeHtml = "";
                if (currentBusDelayInSeconds !== null) {
                    const scheduledSeconds = timeToSeconds(st.arrival_time);
                    if (scheduledSeconds > 0) { // Solo si hay hora programada válida
                        const estimatedSeconds = scheduledSeconds + currentBusDelayInSeconds;
                        const estimatedTimeStr = secondsToTime(estimatedSeconds);
                        estimatedTimeHtml = ` <span class="estimated-time">(Est: ${estimatedTimeStr})</span>`;
                    }
                }
                
                li.innerHTML = `<span class="scheduled-time">${st.arrival_time}</span>${estimatedTimeHtml} - ${paradaTexto} (${st.stop_id})`;  
                routeStopList.appendChild(li);

                const marker = L.marker([stopInfo.stop_lat, stopInfo.stop_lon]).addTo(map);
                marker.bindPopup(`
                    <b>Parada:</b> ${paradaTexto}<br>
                    <b>ID:</b> ${st.stop_id}<br>
                    <b>Hora llegada prog.:</b> ${st.arrival_time}<br>
                    <b>Hora salida prog.:</b> ${st.departure_time}
                `);
                stopMarkers.push(marker);  
                bounds.extend([stopInfo.stop_lat, stopInfo.stop_lon]);
                polylinePoints.push([stopInfo.stop_lat, stopInfo.stop_lon]);
            }
        }

        if (polylinePoints.length > 0) {
            const color = COLORS[Math.floor(Math.random() * COLORS.length)];
            const polyline = L.polyline(polylinePoints, { color: color, weight: 5, opacity: 0.7 }).addTo(map);
            linePolylines.push(polyline);
            if (bounds.isValid()) { // Solo ajustar si hay bounds válidos
                 map.fitBounds(bounds, { padding: [50, 50] });
            }
        } else {
            alert("No se encontraron paradas para este recorrido programado.");
            // No ocultar route-details aquí, puede que el bus sí se haya localizado.
        }

        // MODIFICADO: Llamar a localizarBusEnTiempoReal si no se llamó desde buscarBusPorNumero
        // o si el bus localizado no corresponde a este tripId.
        // La variable currentBusDelayInSeconds ya se habrá establecido (o no) por la llamada a localizarBus...
        // que precede a mostrarRecorrido (en buscarBusPorNumero) o la que se hace aquí abajo.
        let busIsAlreadyCorrectlyMarked = false;
        if (realTimeBusMarker && realTimeBusMarker.getPopup()) {
            const popupContent = realTimeBusMarker.getPopup().getContent();
            // Intentar extraer el trip ID del popup del bus en tiempo real
            // Esto es un poco frágil, depende del formato del popup.
            // Sería mejor si almacenamos el tripId del bus en tiempo real en una variable global.
            // Por ahora, intentamos parsearlo
            const match = popupContent.match(/bizkaibus\.onrender\.com\/bizkaibus[^>]*>\s*([^<]+)<\/a>/); // Esto es muy específico y puede fallar
            // Una forma más robusta sería obtener el trip ID desde el propio objeto del marcador si lo hubiéramos guardado.
            // Por ahora, si `localizarBusEnTiempoReal` ya se ejecutó por `buscarBusPorNumero`
            // y `currentBusDelayInSeconds` está puesto, asumimos que es el bus correcto.
            // Esta lógica es para cuando se selecciona un bus desde la lista de paradas.

            // Si el tripId del bus en tiempo real (obtenido del popup) coincide con el tripId actual,
            // y ya tenemos información de retraso, no hace falta volver a localizar.
            // Esta lógica es compleja de hacer robusta sin guardar el tripId del bus en tiempo real explícitamente.
            // Simplificación: Si currentBusDelayInSeconds no es null, es porque localizarBusEnTiempoReal ya se ejecutó
            // para este tripId (o el vehículo que realiza este tripId).
        }

        // Si venimos de seleccionar un bus de la lista de una parada (buscarBusesPorParada -> click en busOption):
        // O si el `currentBusDelayInSeconds` es null (no se ha localizado aún este trip).
        // No hay una forma 100% fiable de saber si `realTimeBusMarker` corresponde al `tripId` actual
        // sin almacenar explícitamente el tripId del `realTimeBusMarker`.
        // La forma más segura es siempre intentar localizarlo si el origen no fue `buscarBusPorNumero`.
        // Si `currentBusDelayInSeconds` ya tiene un valor, significa que `localizarBusEnTiempoReal`
        // ya fue llamado para este `tripId` (o el vehículo que lo está operando), así que la información de retraso es relevante.
        // Si es `null`, necesitamos obtenerla.
        
        let shouldLocalize = true;
        // Si el marcador de bus en tiempo real existe, y su trip ID (necesitaríamos guardarlo) es el mismo, y hay info de retraso, no localizar.
        // Simplificamos: si no hay info de retraso O no hay marcador, localizamos.
        // Si el marcador existe pero no tenemos info de retraso, también localizamos para obtenerla.
        if (currentBusDelayInSeconds === null) {
            console.log("No hay info de retraso, localizando bus para trip:", tripId);
            await localizarBusEnTiempoReal(tripId, null);
            // Como localizarBusEnTiempoReal ahora actualiza currentBusDelayInSeconds,
            // necesitamos volver a renderizar la lista de paradas para que muestre las estimaciones.
            // Esto podría causar un doble renderizado si `localizarBusEnTiempoReal` es rápido.
            // Una mejor solución sería que localizarBusEnTiempoReal devuelva el retraso y lo pasemos aquí.
            // Por ahora, volvemos a llamar a la parte de renderizado de la lista:
            if (currentBusDelayInSeconds !== null) { // Si se encontró el bus y se calculó el retraso
                routeStopList.innerHTML = ""; // Limpiar de nuevo
                let newBoundsForFit = new L.LatLngBounds(); // Recalcular bounds para el fit
                
                stopsOnRoute.forEach(st => {
                    const stopInfo = stopsData.get(st.stop_id);
                    if (stopInfo) {
                        const paradaTexto = getCleanStopName(st.stop_id);
                        const li = document.createElement("li");
                        let estimatedTimeHtmlRecalc = "";
                        const scheduledSecondsRecalc = timeToSeconds(st.arrival_time);
                        if (scheduledSecondsRecalc > 0) {
                            const estimatedSecondsRecalc = scheduledSecondsRecalc + currentBusDelayInSeconds;
                            const estimatedTimeStrRecalc = secondsToTime(estimatedSecondsRecalc);
                            estimatedTimeHtmlRecalc = ` <span class="estimated-time">(Est: ${estimatedTimeStrRecalc})</span>`;
                        }
                        li.innerHTML = `<span class="scheduled-time">${st.arrival_time}</span>${estimatedTimeHtmlRecalc} - ${paradaTexto} (${st.stop_id})`;
                        routeStopList.appendChild(li);
                        newBoundsForFit.extend([stopInfo.stop_lat, stopInfo.stop_lon]); // Extender bounds
                    }
                });
                 if (realTimeBusMarker && newBoundsForFit.isValid()) {
                    newBoundsForFit.extend(realTimeBusMarker.getLatLng());
                    map.fitBounds(newBoundsForFit, { padding: [70,70] });
                } else if (newBoundsForFit.isValid()){
                    map.fitBounds(newBoundsForFit, { padding: [50,50] });
                }
            }
        } else if (realTimeBusMarker && bounds.isValid()) {
            // Si ya hay bus y retraso, solo ajustar el zoom para incluirlo si es necesario
            bounds.extend(realTimeBusMarker.getLatLng());
            map.fitBounds(bounds, { padding: [70,70] });
        }
    }

    window.onload = async () => {
      await Promise.all([cargarBusInfo(), cargarDatosGTFS()]);  
      document.getElementById('stop-results').style.display = 'none';
      document.getElementById('route-details').style.display = 'none';
      document.getElementById('delay-info').textContent = ''; // NUEVO
    };
  </script>
</body>
</html>
