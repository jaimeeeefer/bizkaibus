<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Bizkaibus en Tiempo Real</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/png" href="/favicon.png">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>
  <h1>Localizador de Autobuses Bizkaibus</h1>
  <div id="controls">
    <input type="text" id="linea" placeholder="Introduce n¬∫ de l√≠nea (ej: A3935 o 3935)" />
    <button onclick="buscarBusesPorLinea()">Buscar L√≠nea</button>
    <input type="text" id="parada" placeholder="Introduce n¬∫ de parada (ej: 123)" />
    <button onclick="buscarBusesPorParada()">Buscar Parada</button>
    <input type="text" id="numBus" placeholder="Introduce n¬∫ de bus (ej: 1514)" />
    <button onclick="buscarBusPorNumero()">Buscar Bus</button>
  </div>
  <div id="stop-results">
    <h2>Pr√≥ximos autobuses en parada:</h2>
    <div id="bus-list"></div>
  </div>
  <div id="route-details" style="display: none;">
    <h2>Detalles del recorrido: <span id="route-line-name"></span></h2>
    <p>Direcci√≥n: <span id="route-headsign"></span></p>
    <p id="delay-info" style="font-weight:bold;"></p>
    <ul id="route-stop-list"></ul>
  </div>
  <div id="map"></div>
  
  <script>
    // Autenticaci√≥n b√°sica por prompt
    const USUARIO = "admin";
    const CONTRASENA = "bizkaibus123";

    function autenticar() {
      const yaAutenticado = localStorage.getItem("autenticado");

      if (yaAutenticado === "true") {
        return;
      }

      const u = prompt("Usuario:");
      const p = prompt("Contrase√±a:");

      if (u === USUARIO && p === CONTRASENA) {
        localStorage.setItem("autenticado", "true");
      } else {
        alert("Acceso denegado. Recarga la p√°gina para intentarlo de nuevo.");
        document.body.innerHTML = "<h1>401 No autorizado</h1><p>Por favor, recarga la p√°gina e introduce las credenciales correctas.</p>";
        throw new Error("Acceso denegado");
      }
    }
    autenticar();
  </script>
  
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    const SHEET_TSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTYeZkna4mwxp3p2azwTgAPcjeSBoUU_rhWW5gVZ7hqotNtojQOHtsjbEnnlJbrijBVwck_kWERE__6/pub?output=tsv"; 
    const STOPS_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibus/main/datos/stops.txt";
    const STOP_TIMES1_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibus/main/datos/stop_times1.txt";
    const STOP_TIMES2_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibus/main/datos/stop_times2.txt";
    const STOP_TIMES3_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibus/main/datos/stop_times3.txt";
    const TRIPS_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibus/main/datos/trips.txt";
    const CALENDAR_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibus/main/datos/calendar.txt";
    const CALENDAR_DATES_URL = "https://raw.githubusercontent.com/jaimeeeefer/bizkaibus/main/datos/calendar_dates.txt";

    let map = L.map("map").setView([43.25, -2.93], 10);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "¬© OpenStreetMap contributors",
    }).addTo(map);

    let markers = [];
    let stopMarkers = [];
    let realTimeBusMarker = null;
    let linePolylines = [];

    let stopsData = new Map();
    let busInfoMap = new Map();
    let stopTimesData = [];
    let tripsData = new Map();
    let calendarData = new Map();
    let calendarDatesData = new Map();

    let currentBusDelayInSeconds = null; 
    let currentBusStopIdRealTime = null;

    const COLORS = ['#FF0000', '#0000FF', '#008000', '#FFA500', '#800080', '#00FFFF', '#FF00FF', '#808080'];

    // 1. √çcono de Bus (rojo) - Usando bus-marker.png (escalado 28x46)
    const busIcon = L.icon({
        iconUrl: './img/bus-marker.png', 
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [28, 46],        // Tama√±o final
        iconAnchor: [14, 46],      // Punto de anclaje
        popupAnchor: [0, -40],     // Posici√≥n del popup
        shadowSize: [41, 41]
    });

    // 2. √çcono de Parada (azul) - Usando stop-marker.png (escalado 28x46)
    const stopIcon = L.icon({
        iconUrl: './img/stop-marker.png', 
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41],        // Proporci√≥n 1.64
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
    });

    async function calentarServidor() {
      try {
        console.log("Enviando solicitud de calentamiento al servidor...");
        await fetch("/bizkaibus");
        console.log("Servidor contactado con √©xito. Deber√≠a estar listo.");
      } catch (error) {
        console.warn("La solicitud de calentamiento fall√≥. La primera b√∫squeda podr√≠a ser lenta:", error);
      }
    }
    
    function timeToSeconds(timeStr) {
        if (!timeStr || !/^\d{2}:\d{2}:\d{2}$/.test(timeStr)) return 0;
        const parts = timeStr.split(':');
        return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);
    }

    function secondsToTime(totalSeconds) {
        if (totalSeconds === null || isNaN(totalSeconds)) return "N/A";
        
        const secondsInDay = 24 * 60 * 60;
        let days = Math.floor(totalSeconds / secondsInDay);
        let remainingSeconds = totalSeconds % secondsInDay;

        if (remainingSeconds < 0) {
            remainingSeconds += secondsInDay;
            days -=1;
        }
        
        const h = Math.floor(remainingSeconds / 3600);
        const m = Math.floor((remainingSeconds % 3600) / 60);
        const s = remainingSeconds % 60;
        
        let timeString = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        if (days > 0) {
            timeString += ` (+${days}d)`;
        } else if (days < 0) {
            timeString += ` (${days}d)`;
        }
        return timeString;
    }

    async function cargarDatosGTFS() {
      try {
        const resStops = await fetch(STOPS_URL);
        const textStops = await resStops.text();
        const rowsStops = textStops.trim().split("\n").map(row => row.split(","));
        
        rowsStops.slice(1).forEach(row => {
          const stop_id = row[0]?.trim();
          if (stop_id && row.length >= 6) {  
              stopsData.set(stop_id, {
                stop_name: row[2]?.trim(),
                stop_lat: parseFloat(row[4]),
                stop_lon: parseFloat(row[5]),
              });
          }
        });

        const stopTimesPromises = [
            fetch(STOP_TIMES1_URL).then(res => res.text()),
            fetch(STOP_TIMES2_URL).then(res => res.text()),
            fetch(STOP_TIMES3_URL).then(res => res.text())
        ];
        const stopTimesTexts = await Promise.all(stopTimesPromises);

        stopTimesTexts.forEach(text => {
            const rowsStopTimes = text.trim().split("\n").map(row => row.split(","));
            rowsStopTimes.slice(1).forEach(row => {
                if (row.length >= 5) {
                    stopTimesData.push({
                        trip_id: row[0]?.trim(),
                        arrival_time: row[1]?.trim(),
                        departure_time: row[2]?.trim(),
                        stop_id: row[3]?.trim(),
                        stop_sequence: parseInt(row[4]),
                    });
                }
            });
        });

        const resTrips = await fetch(TRIPS_URL);
        const textTrips = await resTrips.text();
        const rowsTrips = textTrips.trim().split("\n").map(row => row.split(","));
        rowsTrips.slice(1).forEach(row => {
          if (row.length >= 8) {
              tripsData.set(row[2]?.trim(), {
                route_id: row[0]?.trim(),
                service_id: row[1]?.trim(),
                trip_headsign: row[3]?.trim(),
                shape_id: row[7]?.trim(),
              });
          }
        });

        const resCalendar = await fetch(CALENDAR_URL);
        const textCalendar = await resCalendar.text();
        const rowsCalendar = textCalendar.trim().split("\n").map(row => row.split(","));
        rowsCalendar.slice(1).forEach(row => {
            if (row.length >= 10) {
                calendarData.set(row[0]?.trim(), {
                    monday: parseInt(row[1]),
                    tuesday: parseInt(row[2]),
                    wednesday: parseInt(row[3]),
                    thursday: parseInt(row[4]),
                    friday: parseInt(row[5]),
                    saturday: parseInt(row[6]),
                    sunday: parseInt(row[7]),
                    start_date: row[8]?.trim(),
                    end_date: row[9]?.trim()
                });
            }
        });

        const resCalendarDates = await fetch(CALENDAR_DATES_URL);
        const textCalendarDates = await resCalendarDates.text();
        const rowsCalendarDates = textCalendarDates.trim().split("\n").map(row => row.split(","));
        rowsCalendarDates.slice(1).forEach(row => {
            if (row.length >= 3) {
                const service_id = row[0]?.trim();
                const date = row[1]?.trim();
                const exception_type = parseInt(row[2]);

                if (!calendarDatesData.has(service_id)) {
                    calendarDatesData.set(service_id, new Map());
                }
                calendarDatesData.get(service_id).set(date, exception_type);
            }
        });
        console.log("Carga de datos GTFS completada.");
      } catch (e) {
        console.error("Error cargando datos GTFS:", e);
      }
    }

    async function cargarBusInfo() {
      try {
        const res = await fetch(SHEET_TSV_URL);
        const tsv = await res.text();
        const filas = tsv.trim().split("\n").map(r => r.split("\t"));
        filas.slice(1).forEach(fila => {
          const num = fila[0]?.trim();
          if (num) {
            busInfoMap.set(num, {
              matricula: fila[1]?.trim() || "‚Äî",
              modelo: fila[2]?.trim() || "‚Äî",
              fecha: fila[3]?.trim() || "‚Äî"
            });
          }
        });
      } catch (e) {
        console.error("Error cargando busInfo:", e);
      }
    }

    function getCleanStopName(stopId) {
        const stopInfo = stopsData.get(stopId);
        if (stopInfo) {
            const name = stopInfo.stop_name;
            const regex = new RegExp(`\\s*\\(${stopId}\\)$`);
            return name.replace(regex, '');
        }
        return "Desconocida";
    }

    function extraerNumero(texto) {
      const m = texto.match(/\d+/);
      return m ? m[0] : null;
    }

    function clearMapElements() {
        currentBusDelayInSeconds = null; 
        currentBusStopIdRealTime = null; 
        document.getElementById('delay-info').textContent = ''; 

        if (realTimeBusMarker) {
            map.removeLayer(realTimeBusMarker);
            realTimeBusMarker = null;
        }
        linePolylines.forEach(poly => map.removeLayer(poly));
        linePolylines = [];
        stopMarkers.forEach(m => map.removeLayer(m));
        stopMarkers = [];
    }
    
    function clearLineSearchMarkers() {
        markers.forEach(m => map.removeLayer(m));
        markers = []; 
    }

    async function buscarBusesPorLinea() {
      const inputRaw = document.getElementById("linea").value.trim();
      if (!inputRaw) return alert("Introduce un n√∫mero de l√≠nea v√°lido");

      const input = inputRaw.toUpperCase();
      const inputNum = extraerNumero(inputRaw);

      clearMapElements(); 
      clearLineSearchMarkers(); 

      document.getElementById('stop-results').style.display = 'none';
      document.getElementById('route-details').style.display = 'none';

      try {
        const resp = await fetch("/bizkaibus");
        const xmlText = await resp.text();
        const xml = new DOMParser().parseFromString(xmlText, "application/xml");
        const actividades = xml.getElementsByTagName("VehicleActivity");
        let encontrados = 0;
        let bounds = new L.LatLngBounds();

        for (let act of actividades) {
          const jref = act.querySelector("VehicleJourneyRef")?.textContent.trim().toUpperCase();
          const vref = act.querySelector("VehicleRef")?.textContent.trim();
          const lat = parseFloat(act.querySelector("Latitude")?.textContent);
          const lon = parseFloat(act.querySelector("Longitude")?.textContent);
          const sp = act.querySelector("StopPointRef")?.textContent.trim();

          if (!jref || !vref || isNaN(lat) || isNaN(lon)) continue;

          const match = jref.match(/A\d{3,4}/);
          const lineaLimpia = match ? match[0] : jref;
          const lineaNum = extraerNumero(lineaLimpia);
          const coincide = (
            lineaLimpia === input ||
            (inputNum && lineaNum === inputNum)
          );
          if (!coincide) continue;

          const paradaTexto = sp ? getCleanStopName(sp) : "N/D";
          const infoBus = busInfoMap.get(vref) || { matricula: "‚Äî", modelo: "‚Äî", fecha: "‚Äî"};

          const marcador = L.marker([lat, lon], { icon: busIcon }).addTo(map);
          marcador.bindPopup(`
            <b>L√≠nea:</b> <a href="#" onclick="rellenarYBuscarLinea('${lineaLimpia}'); return false;">${lineaLimpia}</a><br>
            <b>Parada actual/sig.:</b> <a href="#" onclick="rellenarYBuscarParada('${sp}'); return false;">${paradaTexto} ${sp ? '('+sp+')' : ''}</a><br>
            <b>Bus N¬∫:</b> <a href="#" onclick="rellenarYBuscarBus('${vref}'); return false;">${vref}</a><br>
            <b>Matr√≠cula:</b> ${infoBus.matricula}<br>
            <b>Modelo:</b> ${infoBus.modelo}<br>
            <b>Fecha matriculaci√≥n:</b> ${infoBus.fecha}
          `);
          markers.push(marcador);
          bounds.extend([lat, lon]);
          encontrados++;
        }

        if (!encontrados) {
          alert("No se encontraron buses en tiempo real para esa l√≠nea.");
        } else {
            if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
      } catch (e) {
        console.error("Error en buscarBusesPorLinea:", e);
        alert("Error al descargar o procesar datos de Bizkaibus.");
      }
    }

    // --- ¬°FUNCI√ìN MODIFICADA! ---
    async function buscarBusesPorParada() {
        const stopIdInput = document.getElementById("parada").value.trim();
        if (!stopIdInput) {
            return alert("Introduce un n√∫mero de parada v√°lido.");
        }
        const stopId = stopIdInput;
        
        if (!stopsData.has(stopId)) {
            return alert("Parada no encontrada. Introduce un ID de parada v√°lido.");
        }

        clearLineSearchMarkers();
        clearMapElements();  

        document.getElementById('route-details').style.display = 'none';

        const busListDiv = document.getElementById("bus-list");
        busListDiv.innerHTML = "Cargando pr√≥ximos autobuses...";
        document.getElementById('stop-results').style.display = 'block';
        const stopNameForTitle = getCleanStopName(stopId);
        document.getElementById('stop-results').querySelector('h2').textContent = `Pr√≥ximos autobuses en parada: ${stopNameForTitle} (${stopId})`;

        const now = new Date();
        const currentDayOfWeek = now.getDay(); 
        const currentYear = now.getFullYear();
        const currentMonth = (now.getMonth() + 1).toString().padStart(2, '0');
        const currentDay = now.getDate().toString().padStart(2, '0');
        const currentDate = `${currentYear}${currentMonth}${currentDay}`;
        const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
        const currentSeconds = timeToSeconds(currentTime); // Hora actual en segundos

        const realTimeActivities = new Map();
        try {
            const rtResp = await fetch("/bizkaibus");
            const rtXmlText = await rtResp.text();
            const rtXml = new DOMParser().parseFromString(rtXmlText, "application/xml");
            const rtActivityElements = Array.from(rtXml.getElementsByTagName("VehicleActivity"));

            for (let act of rtActivityElements) {
                const jref = act.querySelector("VehicleJourneyRef")?.textContent.trim();
                const spRef = act.querySelector("StopPointRef")?.textContent.trim();
                const recordedAtTimeISO = act.querySelector("RecordedAtTime")?.textContent.trim();
                if (jref && spRef && recordedAtTimeISO) {
                    realTimeActivities.set(jref, {
                        stopPointRef: spRef,
                        recordedAtTimeISO: recordedAtTimeISO
                    });
                }
            }
        } catch (e) {
            console.warn("No se pudieron obtener datos en tiempo real para estimaciones en lista de paradas:", e);
        }

        const upcomingBuses = [];
        const stopTimesAtThisStop = stopTimesData.filter(st => st.stop_id === stopId);

        for (const st of stopTimesAtThisStop) {
            const trip = tripsData.get(st.trip_id);
            if (!trip) continue;

            const service = calendarData.get(trip.service_id);
            if (!service) continue;

            const serviceStartDate = parseInt(service.start_date);
            const serviceEndDate = parseInt(service.end_date);
            const currentFormattedDate = parseInt(currentDate);

            if (currentFormattedDate < serviceStartDate || currentFormattedDate > serviceEndDate) {
                continue; 
            }

            const serviceExceptions = calendarDatesData.get(trip.service_id);
            const currentException = serviceExceptions ? serviceExceptions.get(currentDate) : undefined;

            let runsToday = false;
            if (currentException === 1) runsToday = true;
            else if (currentException === 2) runsToday = false;
            else { 
                switch (currentDayOfWeek) {
                    case 0: runsToday = service.sunday === 1; break; 
                    case 1: runsToday = service.monday === 1; break;
                    case 2: runsToday = service.tuesday === 1; break;
                    case 3: runsToday = service.wednesday === 1; break;
                    case 4: runsToday = service.thursday === 1; break;
                    case 5: runsToday = service.friday === 1; break;
                    case 6: runsToday = service.saturday === 1; break;
                }
            }
            if (!runsToday) continue;

            let estimatedDepartureSeconds = timeToSeconds(st.departure_time);
            let delayStatusText = "";
            let isBusOnTime = false;

            // --- INICIO DE LA MODIFICACI√ìN ---
            if (realTimeActivities.has(st.trip_id)) {
                
                // 1. Obtener todas las paradas de este viaje
                const allStopsForThisTrip = stopTimesData
                    .filter(stop => stop.trip_id === st.trip_id)
                    .sort((a, b) => a.stop_sequence - b.stop_sequence);

                if (allStopsForThisTrip.length > 0) {
                    // 2. Obtener la hora de salida de la primera parada
                    const firstStopDepartureSeconds = timeToSeconds(allStopsForThisTrip[0].departure_time);

                    // 3. Comprobar si el bus ya ha salido de cabecera
                    if (currentSeconds < firstStopDepartureSeconds) {
                        // 4. El bus NO ha salido. Forzar "En hora".
                        isBusOnTime = true;
                        delayStatusText = `<span class="delay-text-stop-list on-time">(En hora)</span>`;
                        estimatedDepartureSeconds = timeToSeconds(st.departure_time);
                    } else {
                        // 5. El bus S√ç ha salido. Calcular retraso real.
                        const liveBusData = realTimeActivities.get(st.trip_id);
                        const liveBusStopSchedule = allStopsForThisTrip.find(
                            rtSt => rtSt.stop_id === liveBusData.stopPointRef
                        );

                        if (liveBusStopSchedule && liveBusData.recordedAtTimeISO) {
                            const scheduledTimeAtLiveBusStopSeconds = timeToSeconds(liveBusStopSchedule.arrival_time);
                            const realTimeDate = new Date(liveBusData.recordedAtTimeISO);
                            const actualTimeAtLiveBusStopStr = `${realTimeDate.getHours().toString().padStart(2, '0')}:${realTimeDate.getMinutes().toString().padStart(2, '0')}:${realTimeDate.getSeconds().toString().padStart(2, '0')}`;
                            const actualTimeAtLiveBusStopSeconds = timeToSeconds(actualTimeAtLiveBusStopStr);

                            if (scheduledTimeAtLiveBusStopSeconds > 0 && actualTimeAtLiveBusStopSeconds > 0) {
                                const delayAtLiveBusStopSeconds = actualTimeAtLiveBusStopSeconds - scheduledTimeAtLiveBusStopSeconds;
                                estimatedDepartureSeconds = timeToSeconds(st.departure_time) + delayAtLiveBusStopSeconds;
                                
                                const delayMinutes = Math.round(delayAtLiveBusStopSeconds / 60);

                                if (delayMinutes > 1) { 
                                    delayStatusText = `<span class="delay-text-stop-list delay">(+${delayMinutes}m)</span>`;
                                } else if (delayMinutes < -1) { 
                                    // Sigue siendo un adelanto (ej. bus va r√°pido entre paradas), pero ya no es el falso adelanto de la cabecera
                                    delayStatusText = `<span class="delay-text-stop-list advance">(${delayMinutes}m)</span>`;
                                } else {
                                    isBusOnTime = true;
                                    delayStatusText = `<span class="delay-text-stop-list on-time">(En hora)</span>`;
                                }
                            }
                        }
                    }
                }
            }
            // --- FIN DE LA MODIFICACI√ìN ---

            if (estimatedDepartureSeconds >= currentSeconds) {
                upcomingBuses.push({
                    linea: trip.route_id,
                    hora: st.departure_time,
                    estimatedDepartureSeconds: estimatedDepartureSeconds,
                    estimatedDepartureTimeDisplay: secondsToTime(estimatedDepartureSeconds).substring(0, 5),
                    delayText: delayStatusText,
                    isBusOnTime: isBusOnTime,
                    destino: trip.trip_headsign,
                    trip_id: st.trip_id,
                    shape_id: trip.shape_id 
                });
            }
        }

        upcomingBuses.sort((a, b) => a.estimatedDepartureSeconds - b.estimatedDepartureSeconds);
        busListDiv.innerHTML = ""; 

        if (upcomingBuses.length > 0) {
            const stopInfo = stopsData.get(stopId);
            if (stopInfo) { 
                const paradaTexto = getCleanStopName(stopId);
                const stopMarker = L.marker([stopInfo.stop_lat, stopInfo.stop_lon], { icon: stopIcon }).addTo(map);
                stopMarker.bindPopup(`<b>Parada:</b> ${paradaTexto} (${stopId})`).openPopup();
                stopMarkers.push(stopMarker); 
                map.setView([stopInfo.stop_lat, stopInfo.stop_lon], 15);
            }

            upcomingBuses.slice(0, 10).forEach(bus => { 
                const busOption = document.createElement("div");
                busOption.classList.add("bus-option");

                let timeDisplay = `Prog.: ${bus.hora.substring(0, 5)}`;
                if (bus.delayText && !bus.isBusOnTime) {
                    timeDisplay += ` Est.: ${bus.estimatedDepartureTimeDisplay}`;
                }
                if (bus.delayText) {
                    timeDisplay += ` ${bus.delayText}`;
                }

                busOption.innerHTML = `
                    <span class="bus-option-linea">L√≠nea: ${bus.linea}</span>
                    <span class="bus-option-hora">${timeDisplay}</span>
                    <span class="bus-option-destino">Destino: ${bus.destino}</span>
                `;
                busOption.onclick = () => {
                    mostrarRecorrido(bus.trip_id, bus.shape_id); 
                };
                busListDiv.appendChild(busOption);
            });
        } else {
            busListDiv.innerHTML = `<p>No hay pr√≥ximos autobuses programados o en tiempo real para esta parada hoy (${currentTime.substring(0,5)}).</p>`;
        }
    }
    // --- FIN DE LA FUNCI√ìN MODIFICADA ---

    function findClosestStopToBus(busPosition, stops) {
        let minDistance = Infinity;
        let closestStop = null;

        stops.forEach(stop => {
            // Distancia cuadrada simple (m√°s eficiente que usar Math.sqrt)
            const distance = Math.pow(busPosition.lat - stop.lat, 2) + Math.pow(busPosition.lon - stop.lon, 2);
            
            if (distance < minDistance) {
                minDistance = distance;
                closestStop = stop;
            }
        });

        return closestStop;
    }

    async function localizarBusEnTiempoReal(tripId, targetStopId = null) {
        // Reiniciar variables globales
        currentBusPosition = null;
        currentBusDelayInSeconds = null;
        currentBusStopIdRealTime = null;

        // 1. Obtener y parsear datos en tiempo real (FRESH FETCH)
        const rtResp = await fetch("https://bizkaibus.pages.dev/bizkaibus");
        const rtXmlText = await rtResp.text();
        const parser = new DOMParser();
        const rtXmlDoc = parser.parseFromString(rtXmlText, "text/xml");
        
        // ASUMIMOS que esta l√≠nea funciona y devuelve el Map con los datos en tiempo real
        const realTimeActivities = parseSIRI(rtXmlDoc); 

        const liveBusData = realTimeActivities.get(tripId);
        const stopsOnRoute = stopTimesData.filter(st => st.trip_id === tripId).sort((a, b) => a.stop_sequence - b.stop_sequence);

        if (liveBusData) {
            // 2. Obtener la parada de referencia: la √∫ltima reportada por el bus (stopPointRef).
            let liveBusStopSchedule = stopsOnRoute.find(
                rtSt => rtSt.stop_id === liveBusData.stopPointRef
            );

            // === L√ìGICA DE CORRECCI√ìN DE RETRASO BASADA EN GPS (EL ARREGLO) ===
            // Se ejecuta si la referencia de parada no es v√°lida (ej. bus en movimiento, entre paradas lejanas o en destino)
            if (!liveBusStopSchedule && liveBusData.recordedAtTimeISO) {
                // Creamos un array de coordenadas de todas las paradas del viaje
                const allStopCoordinates = stopsOnRoute.map(st => ({ 
                    id: st.stop_id, 
                    lat: stopInfo[st.stop_id].stop_lat, 
                    lon: stopInfo[st.stop_id].stop_lon,
                    sequence: st.stop_sequence
                }));
                
                const currentPosition = { 
                    lat: parseFloat(liveBusData.latitude), 
                    lon: parseFloat(liveBusData.longitude) 
                };
                
                // 3. Buscamos la parada m√°s cercana para usarla como referencia de horario.
                const closestStop = findClosestStopToBus(currentPosition, allStopCoordinates);

                if (closestStop) {
                    // Usamos el horario de esa parada cercana para el c√°lculo de retraso
                    liveBusStopSchedule = stopsOnRoute.find(st => st.stop_id === closestStop.id);
                }
            }
            // === FIN L√ìGICA DE CORRECCI√ìN DE RETRASO ===

            // 4. Realizar el c√°lculo del retraso/adelanto
            if (liveBusStopSchedule && liveBusData.recordedAtTimeISO) {
                const scheduledTimeAtLiveBusStopSeconds = timeToSeconds(liveBusStopSchedule.arrival_time);
                const realTimeDate = new Date(liveBusData.recordedAtTimeISO);
                
                const actualTimeAtLiveBusStopStr = `${realTimeDate.getHours().toString().padStart(2, '0')}:${realTimeDate.getMinutes().toString().padStart(2, '0')}:${realTimeDate.getSeconds().toString().padStart(2, '0')}`;
                const actualTimeAtLiveBusStopSeconds = timeToSeconds(actualTimeAtLiveBusStopStr);

                if (scheduledTimeAtLiveBusStopSeconds > 0 && actualTimeAtLiveBusStopSeconds > 0) {
                    // C√°lculo de retraso: (Hora Real de Paso) - (Hora Programada de Paso)
                    currentBusDelayInSeconds = actualTimeAtLiveBusStopSeconds - scheduledTimeAtLiveBusStopSeconds;
                    currentBusStopIdRealTime = liveBusStopSchedule.stop_id;
                }
            }

            // 5. Mostrar la posici√≥n del bus en el mapa
            currentBusPosition = [parseFloat(liveBusData.latitude), parseFloat(liveBusData.longitude)];
            if (realTimeBusMarker) {
                realTimeBusMarker.setLatLng(currentBusPosition);
            } else {
                realTimeBusMarker = L.marker(currentBusPosition, { icon: busIcon }).addTo(map);
                realTimeBusMarker.bindPopup(`Bus n¬∫ ${liveBusData.vehicleRef}`).openPopup();
            }
        }
        
        // 6. Si no hay datos, borrar el marcador
        if (!liveBusData) {
            if (realTimeBusMarker) {
                map.removeLayer(realTimeBusMarker);
                realTimeBusMarker = null;
            }
        }

        // 7. Renderizar la lista de paradas y ajustar el mapa
        if (currentBusDelayInSeconds === null || currentBusStopIdRealTime === null) {
            // L√≥gica de fallback
             await localizarBusEnTiempoReal(tripId, null);
            
            if (currentBusDelayInSeconds !== null || currentBusStopIdRealTime !== null) {
                renderRouteStopList(tripId, stopsOnRoute); 
                if (realTimeBusMarker && mapElementsBounds.isValid()) {
                    mapElementsBounds.extend(realTimeBusMarker.getLatLng());
                    map.fitBounds(mapElementsBounds, { padding: [70,70] });
                } else if (realTimeBusMarker) { 
                    map.setView(realTimeBusMarker.getLatLng(), 15);
                }
            }
        } else if (realTimeBusMarker && mapElementsBounds.isValid()) {
            mapElementsBounds.extend(realTimeBusMarker.getLatLng());
            map.fitBounds(mapElementsBounds, { padding: [70,70] });
        } else if (realTimeBusMarker) {
            map.setView(realTimeBusMarker.getLatLng(), 15);
        }
    }

    async function buscarBusPorNumero() {
        const numBus = document.getElementById("numBus").value.trim();
        if (!numBus) {
            alert("Introduce un n√∫mero de bus v√°lido.");
            return;
        }

        clearMapElements(); 
        clearLineSearchMarkers();
        document.getElementById('stop-results').style.display = 'none';
        document.getElementById('route-details').style.display = 'none'; 

        const foundTripId = await localizarBusEnTiempoReal(null, numBus);

        if (foundTripId) {
            const tripInfo = tripsData.get(foundTripId);
            if (tripInfo) {
                mostrarRecorrido(foundTripId, tripInfo.shape_id);
            } else {
                alert(`Se encontr√≥ el bus ${numBus} pero no se pudo cargar su recorrido completo (faltan datos del viaje).`);
                document.getElementById('route-details').style.display = 'none';
            }
        } else {
            document.getElementById('route-details').style.display = 'none'; 
            alert(`El autob√∫s n¬∫ ${numBus} no se encuentra disponible en tiempo real o no existe.`);
        }
    }

    function renderRouteStopList(tripId, stopsOnRoute) {
        const routeStopList = document.getElementById('route-stop-list');
        routeStopList.innerHTML = ""; 
        let listBounds = new L.LatLngBounds(); 

        stopsOnRoute.forEach(st => {
            const stopInfo = stopsData.get(st.stop_id);
            if (stopInfo) {
                const paradaTexto = getCleanStopName(st.stop_id);
                const li = document.createElement("li");

                let estimatedTimeHtml = "";
                if (currentBusDelayInSeconds !== null) { 
                    const scheduledSeconds = timeToSeconds(st.arrival_time);
                    if (scheduledSeconds > 0) {
                        const estimatedSeconds = scheduledSeconds + currentBusDelayInSeconds;
                        const estimatedTimeStr = secondsToTime(estimatedSeconds);
                        if (Math.abs(currentBusDelayInSeconds) > 60) {
                             estimatedTimeHtml = ` <span class="estimated-time">(Est: ${estimatedTimeStr})</span>`;
                        } else {
                            estimatedTimeHtml = ` <span class="estimated-time">(En hora)</span>`;
                        }
                    }
                }
                
                let waypointIconHtml = "";
                if (currentBusStopIdRealTime && st.stop_id === currentBusStopIdRealTime) {
                    waypointIconHtml = ` <span class="waypoint-icon" title="Ubicaci√≥n actual/pr√≥xima reportada">üìç</span>`;
                }
                
                li.innerHTML = `<span class="scheduled-time">${st.arrival_time}</span>${estimatedTimeHtml} - ${paradaTexto} (${st.stop_id})${waypointIconHtml}`;  
                routeStopList.appendChild(li);
                listBounds.extend([stopInfo.stop_lat, stopInfo.stop_lon]); 
            }
        });
        return listBounds; 
    }

    async function mostrarRecorrido(tripId, shapeId) {
        clearLineSearchMarkers();
        stopMarkers.forEach(m => map.removeLayer(m));
        stopMarkers = [];
        linePolylines.forEach(poly => map.removeLayer(poly));
        linePolylines = [];

        document.getElementById('stop-results').style.display = 'none';
        document.getElementById('route-details').style.display = 'block';

        const trip = tripsData.get(tripId);
        if (!trip) {
            alert("Informaci√≥n del viaje no encontrada.");
            document.getElementById('route-details').style.display = 'none';
            return;
        }

        document.getElementById('route-line-name').textContent = trip.route_id;
        document.getElementById('route-headsign').textContent = trip.trip_headsign;
        
        const stopsOnRoute = stopTimesData
            .filter(st => st.trip_id === tripId)
            .sort((a, b) => a.stop_sequence - b.stop_sequence);

        renderRouteStopList(tripId, stopsOnRoute); 
        
        let mapElementsBounds = new L.LatLngBounds(); 
        let polylinePoints = [];

        stopsOnRoute.forEach(st => {
            const stopInfo = stopsData.get(st.stop_id);
            if (stopInfo) {
                 const marker = L.marker([stopInfo.stop_lat, stopInfo.stop_lon], { icon: stopIcon }).addTo(map);
                 marker.bindPopup(`
                    <b>Parada:</b> ${getCleanStopName(st.stop_id)}<br>
                    <b>ID:</b> ${st.stop_id}<br>
                    <b>Hora llegada prog.:</b> ${st.arrival_time}<br>
                    <b>Hora salida prog.:</b> ${st.departure_time}
                `);
                stopMarkers.push(marker);
                polylinePoints.push([stopInfo.stop_lat, stopInfo.stop_lon]);
                mapElementsBounds.extend([stopInfo.stop_lat, stopInfo.stop_lon]);
            }
        });

        if (polylinePoints.length > 0) {
            const color = COLORS[Math.floor(Math.random() * COLORS.length)];
            const polyline = L.polyline(polylinePoints, { color: color, weight: 5, opacity: 0.7 }).addTo(map);
            linePolylines.push(polyline);
            if (mapElementsBounds.isValid()) { 
                 map.fitBounds(mapElementsBounds, { padding: [50, 50] });
            }
        }

        if (currentBusDelayInSeconds === null || currentBusStopIdRealTime === null) {
            await localizarBusEnTiempoReal(tripId, null);
            
            if (currentBusDelayInSeconds !== null || currentBusStopIdRealTime !== null) {
                renderRouteStopList(tripId, stopsOnRoute); 
                if (realTimeBusMarker && mapElementsBounds.isValid()) {
                    mapElementsBounds.extend(realTimeBusMarker.getLatLng());
                    map.fitBounds(mapElementsBounds, { padding: [70,70] });
                } else if (realTimeBusMarker) { 
                    map.setView(realTimeBusMarker.getLatLng(), 15);
                }
            }
        } else if (realTimeBusMarker && mapElementsBounds.isValid()) {
            mapElementsBounds.extend(realTimeBusMarker.getLatLng());
            map.fitBounds(mapElementsBounds, { padding: [70,70] });
        } else if (realTimeBusMarker) {
            map.setView(realTimeBusMarker.getLatLng(), 15);
        }
    }

    function rellenarYBuscarLinea(lineaId) {
        document.getElementById("linea").value = lineaId;
        document.getElementById("parada").value = "";
        document.getElementById("numBus").value = "";
        buscarBusesPorLinea(); 
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    function rellenarYBuscarParada(paradaId) {
        if (!paradaId) return;
        document.getElementById("parada").value = paradaId;
        document.getElementById("linea").value = "";
        document.getElementById("numBus").value = "";
        buscarBusesPorParada(); 
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    function rellenarYBuscarBus(busNumero) {
        document.getElementById("numBus").value = busNumero;
        document.getElementById("linea").value = "";
        document.getElementById("parada").value = "";
        buscarBusPorNumero(); 
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    window.onload = async () => {
      calentarServidor();
      await Promise.all([cargarBusInfo(), cargarDatosGTFS()]);  
      document.getElementById('stop-results').style.display = 'none';
      document.getElementById('route-details').style.display = 'none';
      document.getElementById('delay-info').textContent = ''; 
    };
  </script>
</body>
</html>