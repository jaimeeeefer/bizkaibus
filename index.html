<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Localizador de Autobuses Bizkaibus</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet/dist/leaflet.css"
  />
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    h1, h2 {
      text-align: center;
    }
    input, button {
      padding: 10px;
      margin: 5px;
    }
    #bus-list, .bus-option {
      padding: 10px;
      margin: 5px 0;
      border: 1px solid #ccc;
    }
    .bus-option-linea {
      font-weight: bold;
    }
    .bus-option-hora, .bus-option-destino {
      margin-left: 10px;
    }
    .delay-text-stop-list.delay {
      color: red;
    }
    .delay-text-stop-list.advance {
      color: orange;
    }
    .delay-text-stop-list.on-time {
      color: green;
    }
    #map {
      height: 400px;
      margin-top: 20px;
    }
    /* Para la lista de paradas en el recorrido */
    #stop-sequence {
      list-style: none;
      padding-left: 0;
      margin-top: 10px;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #ccc;
    }
    #stop-sequence li {
      padding: 5px;
      border-bottom: 1px solid #eee;
    }
  </style>
</head>
<body>
  <h1>Localizador de Autobuses Bizkaibus</h1>

  <div style="text-align:center;">
    <input id="linea" placeholder="Introduce nº de línea (ej: A3935 o 3935)">
    <button onclick="buscarPorLinea()">Buscar Línea</button>
    <input id="parada" placeholder="Introduce nº de parada (ej: 411)">
    <button onclick="buscarBusesPorParada()">Buscar Parada</button>
    <input id="busid" placeholder="Introduce nº de bus (trip_id parcial)">
    <button onclick="buscarPorBusId()">Buscar Bus</button>
  </div>

  <div id="stop-results" style="display:none;">
    <h2></h2>
    <div id="bus-list"></div>
  </div>

  <div id="route-details" style="display:none;">
    <h2 id="route-title">Detalles del recorrido:</h2>
    <div id="delay-info" style="margin: 10px 0; font-weight: bold;"></div>
    <div id="map"></div>
    <ul id="stop-sequence"></ul>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- gtfs-data.js debe definir las siguientes estructuras:
       - stopsData: Map<stop_id, {stop_id, stop_name, stop_lat, stop_lon}>
       - stopTimesData: Array<{trip_id, arrival_time, departure_time, stop_id, stop_sequence}>
       - tripsData: Map<trip_id, {route_id, service_id, trip_headsign, shape_id}>
       - calendarData: Map<service_id, {monday, tuesday, wednesday, thursday, friday, saturday, sunday, start_date, end_date}>
       - calendarDatesData: Map<service_id, Map<YYYYMMDD, exception_type>>
       - shapesData: Map<shape_id, Array<{shape_pt_lat, shape_pt_lon, shape_pt_sequence}>>
       - routesData: Map<route_id, {route_short_name, route_long_name, route_type}>
  -->
  <script src="gtfs-data.js"></script>

  <script>
    // ===================================================================
    // Variables globales para Leaflet
    // ===================================================================
    let map, stopMarkers = [], busMarker = null, routePolyline = null;

    function inicializarMapa() {
      if (map) return;
      map = L.map('map').setView([43.2627, -2.9253], 12); // Centrado en Bizkaia
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap'
      }).addTo(map);
    }

    function clearMapElements() {
      stopMarkers.forEach(m => map.removeLayer(m));
      stopMarkers = [];
      if (busMarker) {
        map.removeLayer(busMarker);
        busMarker = null;
      }
      if (routePolyline) {
        map.removeLayer(routePolyline);
        routePolyline = null;
      }
      document.getElementById('stop-sequence').innerHTML = '';
      document.getElementById('delay-info').textContent = '';
    }

    function clearLineSearchMarkers() {
      // Por si en otras búsquedas quieres limpiar marcadores previos
      clearMapElements();
    }

    // ===================================================================
    // Helpers de tiempo (HH:MM:SS <-> segundos)
    // ===================================================================
    function timeToSeconds(hms) {
      const parts = hms.split(':').map(p => parseInt(p, 10));
      if (parts.length !== 3 || parts.some(isNaN)) return 0;
      return parts[0] * 3600 + parts[1] * 60 + parts[2];
    }

    function secondsToTime(seconds) {
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = seconds % 60;
      return (
        String(h).padStart(2, '0') + ':' +
        String(m).padStart(2, '0') + ':' +
        String(s).padStart(2, '0')
      );
    }

    // ===================================================================
    // Carga de datos GTFS en memoria (ya están en gtfs-data.js)
    // ===================================================================
    async function cargarDatosGTFS() {
      // Suponemos que gtfs-data.js ya ha poblado:
      // stopsData, stopTimesData, tripsData, calendarData, calendarDatesData, shapesData, routesData
      // Por seguridad, podríamos verificar que existan:
      if (
        typeof stopsData === 'undefined' ||
        typeof stopTimesData === 'undefined' ||
        typeof tripsData === 'undefined' ||
        typeof calendarData === 'undefined' ||
        typeof calendarDatesData === 'undefined' ||
        typeof shapesData === 'undefined' ||
        typeof routesData === 'undefined'
      ) {
        return alert('Error: No se han cargado correctamente los datos GTFS (gtfs-data.js).');
      }
    }

    // ===================================================================
    // BUSCAR POR PARADA: muestra próximos buses (programado + estimado)
    // ===================================================================
    async function buscarBusesPorParada() {
      const stopIdInput = document.getElementById("parada").value.trim();
      if (!stopIdInput) {
        return alert("Introduce un número de parada válido.");
      }
      const stopId = stopIdInput;

      if (!stopsData.has(stopId)) {
        return alert("Parada no encontrada. Introduce un ID de parada válido.");
      }

      clearLineSearchMarkers();
      document.getElementById('route-details').style.display = 'none';

      const busListDiv = document.getElementById("bus-list");
      busListDiv.innerHTML = "Cargando próximos autobuses…";
      document.getElementById('stop-results').style.display = 'block';
      const stopNameForTitle = stopsData.get(stopId).stop_name;
      document.getElementById('stop-results').querySelector('h2').textContent =
        `Próximos autobuses en parada: ${stopNameForTitle} (${stopId})`;

      // Fecha y hora actual
      const now = new Date();
      const currentDayOfWeek = now.getDay(); // 0=domingo, 1=lunes, …
      const YYYY = now.getFullYear();
      const MM = String(now.getMonth() + 1).padStart(2, '0');
      const DD = String(now.getDate()).padStart(2, '0');
      const currentDate = `${YYYY}${MM}${DD}`;   // Ej: "20250602"
      const HH = String(now.getHours()).padStart(2,'0');
      const NN = String(now.getMinutes()).padStart(2,'0');
      const SS = String(now.getSeconds()).padStart(2,'0');
      const currentTime = `${HH}:${NN}:${SS}`;

      // 1) Traer datos en tiempo real
      const realTimeActivities = new Map();
      try {
        const rtResp = await fetch("https://bizkaibus.onrender.com/bizkaibus");
        const rtXmlText = await rtResp.text();
        const rtXml = new DOMParser().parseFromString(rtXmlText, "application/xml");
        const rtActivityElements = rtXml.getElementsByTagName("VehicleActivity");

        for (let act of rtActivityElements) {
          const jref = act.querySelector("VehicleJourneyRef")?.textContent.trim();
          const spRef = act.querySelector("StopPointRef")?.textContent.trim();
          const recordedAtTimeISO = act.querySelector("RecordedAtTime")?.textContent.trim();
          // Ubicación exacta del vehículo en vehículo en ruta:
          const lonNode = act.querySelector("Longitude");
          const latNode = act.querySelector("Latitude");
          const lon = lonNode ? parseFloat(lonNode.textContent.trim()) : null;
          const lat = latNode ? parseFloat(latNode.textContent.trim()) : null;

          if (jref && spRef && recordedAtTimeISO) {
            realTimeActivities.set(jref, {
              stopPointRef: spRef,
              recordedAtTimeISO,
              lon,
              lat
            });
          }
        }
      } catch (e) {
        console.warn("No se pudieron obtener datos en tiempo real:", e);
      }

      // 2) Filtrar stop_times de esta parada
      const stopTimesAtThisStop = stopTimesData.filter(st => st.stop_id === stopId);
      const upcomingBuses = [];

      for (const st of stopTimesAtThisStop) {
        const trip = tripsData.get(st.trip_id);
        if (!trip) continue;

        // 2.1) ¿Este servicio corre hoy?
        const service = calendarData.get(trip.service_id);
        if (!service) continue;

        const startDateNum = parseInt(service.start_date);
        const endDateNum   = parseInt(service.end_date);
        const currDateNum  = parseInt(currentDate);
        if (currDateNum < startDateNum || currDateNum > endDateNum) {
          continue;
        }
        // Excepciones (calendar_dates)
        const exceptionsMap = calendarDatesData.get(trip.service_id);
        const todayException = exceptionsMap ? exceptionsMap.get(currentDate) : undefined;
        let runsToday = false;
        if (todayException === 1) {
          runsToday = true;
        } else if (todayException === 2) {
          runsToday = false;
        } else {
          switch (currentDayOfWeek) {
            case 0: runsToday = service.sunday === 1; break;
            case 1: runsToday = service.monday === 1; break;
            case 2: runsToday = service.tuesday === 1; break;
            case 3: runsToday = service.wednesday === 1; break;
            case 4: runsToday = service.thursday === 1; break;
            case 5: runsToday = service.friday === 1; break;
            case 6: runsToday = service.saturday === 1; break;
          }
        }
        if (!runsToday) continue;

        // 2.2) Hora programada en esta parada (en segundos)
        const scheduledSeconds = timeToSeconds(st.departure_time);

        // 2.3) Intentar emparejar trip_id con jref (llave de realTimeActivities)
        let bestMatchKey = null;
        for (let liveKey of realTimeActivities.keys()) {
          if (liveKey.includes(st.trip_id) || st.trip_id.includes(liveKey)) {
            bestMatchKey = liveKey;
            break;
          }
        }

        let estimatedSeconds = scheduledSeconds;
        let delayText = "";
        let isOnTime = false;

        if (bestMatchKey) {
          const liveData = realTimeActivities.get(bestMatchKey);
          // Buscar el stop_time de esa parada en la que está ahora
          const liveStopSchedule = stopTimesData.find(
            rtSt => rtSt.trip_id === st.trip_id && rtSt.stop_id === liveData.stopPointRef
          );

          if (liveStopSchedule && liveData.recordedAtTimeISO) {
            const scheduledAtLiveStop = timeToSeconds(liveStopSchedule.arrival_time);
            const realDate = new Date(liveData.recordedAtTimeISO);
            const realH = String(realDate.getHours()).padStart(2,'0');
            const realM = String(realDate.getMinutes()).padStart(2,'0');
            const realS = String(realDate.getSeconds()).padStart(2,'0');
            const realAtLiveStop = timeToSeconds(`${realH}:${realM}:${realS}`);

            if (scheduledAtLiveStop > 0 && realAtLiveStop > 0) {
              const diffSec = realAtLiveStop - scheduledAtLiveStop;
              estimatedSeconds = scheduledSeconds + diffSec;
              const diffMin = Math.round(diffSec / 60);
              if (diffMin > 1) {
                delayText = `<span class="delay-text-stop-list delay">(+${diffMin}m)</span>`;
              } else if (diffMin < -1) {
                delayText = `<span class="delay-text-stop-list advance">(${diffMin}m)</span>`;
              } else {
                isOnTime = true;
                delayText = `<span class="delay-text-stop-list on-time">(En hora)</span>`;
              }
            }
          }
        }

        // 2.4) Incluir solo si aún no ha salido
        const nowSec = timeToSeconds(currentTime);
        if (estimatedSeconds >= nowSec) {
          upcomingBuses.push({
            linea: trip.route_id,
            horaProg: st.departure_time,
            horaEstSecs: estimatedSeconds,
            horaEst: secondsToTime(estimatedSeconds).substring(0,5),
            delayText,
            isOnTime,
            destino: trip.trip_headsign,
            trip_id: st.trip_id,
            shape_id: trip.shape_id
          });
        }
      }

      // 3) Ordenar por hora estimada y mostrar
      upcomingBuses.sort((a, b) => a.horaEstSecs - b.horaEstSecs);
      busListDiv.innerHTML = "";

      if (upcomingBuses.length > 0) {
        // Colocar marcador de la propia parada
        const stopInfo = stopsData.get(stopId);
        if (stopInfo) {
          inicializarMapa();
          const marker = L.marker([stopInfo.stop_lat, stopInfo.stop_lon]).addTo(map);
          marker.bindPopup(`<b>Parada:</b> ${stopInfo.stop_name} (${stopId})`).openPopup();
          stopMarkers.push(marker);
          map.setView([stopInfo.stop_lat, stopInfo.stop_lon], 15);
        }

        upcomingBuses.slice(0, 10).forEach(bus => {
          const div = document.createElement("div");
          div.classList.add("bus-option");

          let horario = `Prog.: ${bus.horaProg.substring(0,5)}`;
          horario += `  ·  Est.: ${bus.horaEst}`;
          if (bus.delayText) {
            horario += `  ${bus.delayText}`;
          }

          div.innerHTML = `
            <span class="bus-option-linea">Línea: ${bus.linea}</span>
            <span class="bus-option-hora">${horario}</span>
            <span class="bus-option-destino">Destino: ${bus.destino}</span>
          `;
          div.onclick = () => {
            mostrarRecorrido(bus.trip_id, bus.shape_id);
          };
          busListDiv.appendChild(div);
        });
      } else {
        busListDiv.innerHTML =
          `<p>No hay próximos autobuses programados o en tiempo real para esta parada hoy (${currentTime.substring(0,5)}).</p>`;
      }
    }

    // ===================================================================
    // MOSTRAR RECORRIDO: dibuja ruta GTFS y, si existe, la posición real del bus
    // ===================================================================
    async function mostrarRecorrido(tripId, shapeId) {
      clearMapElements();
      document.getElementById('route-details').style.display = 'block';
      document.getElementById('route-title').textContent = `Detalles del recorrido: ${tripId}`;

      inicializarMapa();

      // 1) Dibujar polilínea del shape (itinerario)
      const shapeCoords = shapesData.get(shapeId) || [];
      if (shapeCoords.length > 0) {
        const latlngs = shapeCoords
          .sort((a, b) => a.shape_pt_sequence - b.shape_pt_sequence)
          .map(pt => [pt.shape_pt_lat, pt.shape_pt_lon]);
        routePolyline = L.polyline(latlngs, { color: 'blue' }).addTo(map);
        map.fitBounds(routePolyline.getBounds(), { padding: [20,20] });
      }

      // 2) Pintar secuencia de paradas del tripId
      const stopsOfTrip = stopTimesData
        .filter(st => st.trip_id === tripId)
        .sort((a, b) => a.stop_sequence - b.stop_sequence);

      const ul = document.getElementById('stop-sequence');
      ul.innerHTML = "";
      stopsOfTrip.forEach(st => {
        const stopInfo = stopsData.get(st.stop_id);
        const li = document.createElement('li');
        if (stopInfo) {
          li.textContent = `${st.arrival_time.substring(0,8)} – ${stopInfo.stop_name} (${st.stop_id})`;
        } else {
          li.textContent = `${st.arrival_time.substring(0,8)} – Parada: ${st.stop_id}`;
        }
        ul.appendChild(li);
      });

      // 3) Intentar obtener posición en tiempo real de este tripId
      let realPosition = null;
      let realDelayText = "";
      try {
        const rtResp = await fetch("https://bizkaibus.onrender.com/bizkaibus");
        const rtXmlText = await rtResp.text();
        const rtXml = new DOMParser().parseFromString(rtXmlText, "application/xml");
        const activities = rtXml.getElementsByTagName("VehicleActivity");

        // Reconstruir Map temporalmente (podríamos reutilizar el cache anterior,
        // pero por simplicidad lo hacemos de nuevo aquí)
        for (let act of activities) {
          const jref = act.querySelector("VehicleJourneyRef")?.textContent.trim();
          if (!jref) continue;
          // Comparar con nuestro tripId
          if (jref.includes(tripId) || tripId.includes(jref)) {
            // Extraer posición
            const lonNode = act.querySelector("Longitude");
            const latNode = act.querySelector("Latitude");
            const lon = lonNode ? parseFloat(lonNode.textContent.trim()) : null;
            const lat = latNode ? parseFloat(latNode.textContent.trim()) : null;
            // Extraer parada actual para calcular delay en este punto
            const spRef = act.querySelector("StopPointRef")?.textContent.trim();
            const recordedAt = act.querySelector("RecordedAtTime")?.textContent.trim();

            realPosition = { lon, lat, spRef, recordedAt };
            break;
          }
        }
      } catch (e) {
        console.warn("Error al obtener posición en tiempo real:", e);
      }

      if (realPosition && realPosition.lat !== null && realPosition.lon !== null) {
        // 3.1) Dibujar marcador del autobús
        busMarker = L.marker([realPosition.lat, realPosition.lon], {
          icon: L.icon({
            iconUrl: "https://cdn-icons-png.flaticon.com/512/61/61088.png",
            iconSize: [32, 32],
            iconAnchor: [16, 16]
          })
        }).addTo(map);
        busMarker.bindPopup(`<b>Autobús encontrado</b><br>Última posición a las ${new Date(realPosition.recordedAt).toLocaleTimeString()}`).openPopup();
        stopMarkers.push(busMarker);

        // 3.2) Calcular y mostrar el delay aproximado (opcional)
        if (realPosition.spRef && realPosition.recordedAt) {
          // Encontrar el stop_time de esa parada en GTFS
          const liveStopSch = stopTimesData.find(
            st => st.trip_id === tripId && st.stop_id === realPosition.spRef
          );
          if (liveStopSch) {
            const scheduledAtLive = timeToSeconds(liveStopSch.arrival_time);
            const realDateObj = new Date(realPosition.recordedAt);
            const realH = String(realDateObj.getHours()).padStart(2,'0');
            const realM = String(realDateObj.getMinutes()).padStart(2,'0');
            const realS = String(realDateObj.getSeconds()).padStart(2,'0');
            const realAtLive = timeToSeconds(`${realH}:${realM}:${realS}`);
            if (scheduledAtLive > 0 && realAtLive > 0) {
              const diffSec = realAtLive - scheduledAtLive;
              const diffMin = Math.round(diffSec / 60);
              if (diffMin > 1) {
                realDelayText = `Retraso: +${diffMin} min`;
              } else if (diffMin < -1) {
                realDelayText = `Adelantado: ${diffMin} min`;
              } else {
                realDelayText = `En hora`;
              }
            }
          }
        }

        document.getElementById('delay-info').textContent = realDelayText;
      } else {
        // 4) Si no se localiza en tiempo real
        document.getElementById('delay-info').textContent = 'Autobús no localizado en tiempo real.';
      }
    }

    // ===================================================================
    // BUSCAR POR LÍNEA (ejemplo muy sencillo: marcador de toda la ruta)
    // ===================================================================
    function buscarPorLinea() {
      const lineaInput = document.getElementById("linea").value.trim();
      if (!lineaInput) return alert("Introduce un número de línea.");
      // Aquí podrías filtrar tripsData por route_id = lineaInput y mostrar itinerarios,
      // buses en ruta, etc. A modo de ejemplo sencillo, solo centramos el mapa.
      alert("Función buscarPorLinea() no implementada en detalle. Debes filtrar los trips de esa ruta.");
    }

    // ===================================================================
    // BUSCAR POR BUSID (trip_id parcial)
    // ===================================================================
    function buscarPorBusId() {
      const busIdInput = document.getElementById("busid").value.trim();
      if (!busIdInput) return alert("Introduce un trip_id (o parte de él).");
      // Buscamos el primer trip_id que coincida o contenga el texto
      const match = Array.from(tripsData.keys()).find(k => k.includes(busIdInput));
      if (!match) return alert("Trip_id no encontrado en GTFS.");
      const trip = tripsData.get(match);
      mostrarRecorrido(match, trip.shape_id);
      // También podrías centrar el mapa en la ruta y mostrar paradas, como en mostrarRecorrido.
    }

    // ===================================================================
    // Onload: cargar GTFS y ocultar secciones
    // ===================================================================
    window.onload = async () => {
      await cargarDatosGTFS();
      document.getElementById('stop-results').style.display = 'none';
      document.getElementById('route-details').style.display = 'none';
    };
  </script>
</body>
</html>
